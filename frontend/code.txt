`.env`

```
#REACT_APP_API_BASE_URL=http://localhost:5001/api
# OR for Vite:
VITE_API_BASE_URL=http://localhost:5001/api

```

`code.txt`

```

```

`eslint.config.js`

```javascript
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'

export default [
  { ignores: ['dist'] },
  {
    files: ['**/*.{js,jsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
      parserOptions: {
        ecmaVersion: 'latest',
        ecmaFeatures: { jsx: true },
        sourceType: 'module',
      },
    },
    plugins: {
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...js.configs.recommended.rules,
      ...reactHooks.configs.recommended.rules,
      'no-unused-vars': ['error', { varsIgnorePattern: '^[A-Z_]' }],
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  },
]

```

`index.html`

```html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + React</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>

```

`o.txt`

```

```

`postcss.config.js`

```javascript
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}

```

`src/App.css`

```css
/* #root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
} */

```

`src/App.jsx`

```javascript
// // import { useState } from 'react'
// // import reactLogo from './assets/react.svg'
// // import viteLogo from '/vite.svg'
// // import './App.css'

// // function App() {
// //   const [count, setCount] = useState(0)

// //   return (
// //     <>
// //       <div>
// //         <a href="https://vite.dev" target="_blank">
// //           <img src={viteLogo} className="logo" alt="Vite logo" />
// //         </a>
// //         <a href="https://react.dev" target="_blank">
// //           <img src={reactLogo} className="logo react" alt="React logo" />
// //         </a>
// //       </div>
// //       <h1>Vite + React</h1>
// //       <div className="card">
// //         <button onClick={() => setCount((count) => count + 1)}>
// //           count is {count}
// //         </button>
// //         <p>
// //           Edit <code>src/App.jsx</code> and save to test HMR
// //         </p>
// //       </div>
// //       <p className="read-the-docs">
// //         Click on the Vite and React logos to learn more
// //       </p>
// //     </>
// //   )
// // }

// // export default App

// import React, { useState, useEffect, useCallback } from 'react';
// import { useAuth } from './hooks/useAuth';
// import { useAppState } from './contexts/AppStateContext';
// import AuthModal from './components/auth/AuthModal';
// import TopNav from './components/layout/TopNav';
// import LeftPanel from './components/layout/LeftPanel';
// import CenterPanel from './components/layout/CenterPanel';
// import RightPanel from './components/layout/RightPanel';
// import api from './services/api'; // Your API service functions
// import toast from 'react-hot-toast';
// import { motion, AnimatePresence } from 'framer-motion';

// // Icons
// import { AlertTriangle, CheckCircle2 } from 'lucide-react';


// function App() {
//     const { token, user, loading: authLoading, logout, setUser: setAuthUser } = useAuth();
//     const { 
//         theme, 
//         selectedLLM,
//         isLeftPanelOpen, setIsLeftPanelOpen,
//         isRightPanelOpen, setIsRightPanelOpen,
//         currentSessionId, setSessionId: setGlobalSessionId 
//     } = useAppState();
    
//     const [showAuthModal, setShowAuthModal] = useState(false);
//     const [messages, setMessages] = useState([]);
//     const [chatStatus, setChatStatus] = useState(''); // e.g., "Thinking...", "Responded"
//     const [orchestratorStatus, setOrchestratorStatus] = useState({ status: "loading", message: "Connecting..." });


//     // Initialize theme
//     useEffect(() => {
//         if (theme === 'dark') {
//             document.documentElement.classList.add('dark');
//         } else {
//             document.documentElement.classList.remove('dark');
//         }
//     }, [theme]);

//     // Check auth status on initial load
//     useEffect(() => {
//         if (!authLoading && !token) {
//             setShowAuthModal(true);
//         } else if (token && !currentSessionId) {
//             // If logged in but no session, create one
//             api.startNewSession().then(data => {
//                 setGlobalSessionId(data.sessionId);
//             }).catch(err => {
//                 toast.error("Failed to start a new session.");
//                 console.error(err);
//             });
//         }
//     }, [token, authLoading, currentSessionId, setGlobalSessionId]);

//     // Fetch orchestrator status
//     useEffect(() => {
//         const fetchStatus = async () => {
//             const statusData = await api.getOrchestratorStatus();
//             setOrchestratorStatus(statusData);
//         };
//         fetchStatus();
//         const intervalId = setInterval(fetchStatus, 20000); // Check every 20s
//         return () => clearInterval(intervalId);
//     }, []);

//     // Fetch chat history when session ID changes
//     const fetchChatHistory = useCallback(async (sid) => {
//         if (!sid || !token) {
//             setMessages([]); // Clear messages if no session or token
//             return;
//         }
//         setChatStatus("Loading history...");
//         try {
//             const historyData = await api.getChatHistory(sid); // Token is auto-included by axios interceptor
//             const formattedMessages = (Array.isArray(historyData) ? historyData : []).map(msg => ({
//                 id: msg.id || msg._id || String(Math.random()),
//                 sender: msg.role === 'model' ? 'bot' : 'user',
//                 text: msg.parts && msg.parts.length > 0 ? msg.parts[0].text : (msg.text || ''), // Handle both structures
//                 thinking: msg.thinking,
//                 references: msg.references || [],
//                 timestamp: msg.timestamp
//             }));
//             setMessages(formattedMessages);
//             setChatStatus(formattedMessages.length > 0 ? "History loaded." : "New chat. Send a message to start!");
//         } catch (error) {
//             toast.error(`Failed to load chat history: ${error.message}`);
//             setChatStatus("Error loading history.");
//             console.error("Failed to load chat history:", error);
//         }
//     }, [token]);

//     useEffect(() => {
//         if (currentSessionId && token) {
//             fetchChatHistory(currentSessionId);
//         } else if (!token) {
//             setMessages([]); // Clear messages if logged out
//         }
//     }, [currentSessionId, token, fetchChatHistory]);


//     const handleAuthSuccess = (authData) => { // authData contains { token, username, _id, sessionId }
//         setShowAuthModal(false);
//         // AuthContext already sets token and user from its login/signup methods
//         // App.js just needs to use the sessionId provided
//         if (authData.sessionId) {
//             setGlobalSessionId(authData.sessionId);
//         }
//         // If authData.user is more complete, update AuthContext's user
//         if(authData.username && authData._id){
//             setAuthUser({username: authData.username, id: authData._id});
//         }
//     };
    
//     const handleLogout = () => {
//         logout();
//         setGlobalSessionId(null); // Clear session on logout
//         setShowAuthModal(true); // Show auth modal after logout
//         toast.success("Logged out successfully.");
//     };

//     const handleNewChat = async () => {
//         try {
//             const data = await api.startNewSession();
//             setGlobalSessionId(data.sessionId);
//             setMessages([]); // Clear current messages for the new chat
//             setChatStatus("New chat started. Send a message!");
//             toast.success("New chat started!");
//         } catch (error) {
//             toast.error("Failed to start new chat.");
//             console.error("Failed to start new chat:", error);
//         }
//     };


//     if (authLoading) {
//         return (
//             <div className="fixed inset-0 flex items-center justify-center bg-background-dark dark:bg-opacity-80">
//                 <div className="animate-spin rounded-full h-16 w-16 border-t-4 border-b-4 border-primary"></div>
//                 <p className="ml-4 text-xl text-text-dark">Initializing...</p>
//             </div>
//         );
//     }

//     return (
//         <div className={`flex flex-col h-screen overflow-hidden font-sans ${theme}`}>
//             <AnimatePresence>
//                 {showAuthModal && !token && (
//                     <AuthModal isOpen={showAuthModal} onClose={handleAuthSuccess} />
//                 )}
//             </AnimatePresence>

//             {token && user && (
//                 <>
//                     <TopNav
//                         user={user}
//                         onLogout={handleLogout}
//                         onNewChat={handleNewChat}
//                         onHistoryClick={() => { /* TODO: Implement History Modal/Panel */ toast.info("History feature coming soon!"); }}
//                         onLLMSwitchClick={() => { /* TODO: Implement LLM Switch Modal */ toast.info("LLM switching coming soon!"); }}
//                         orchestratorStatus={orchestratorStatus}
//                     />
//                     <div className="flex flex-1 overflow-hidden pt-16"> {/* pt-16 for fixed TopNav height */}
//                         {/* Left Panel */}
//                         <AnimatePresence>
//                         {isLeftPanelOpen && (
//                             <motion.aside 
//                                 initial={{ x: '-100%', opacity: 0 }}
//                                 animate={{ x: '0%', opacity: 1 }}
//                                 exit={{ x: '-100%', opacity: 0 }}
//                                 transition={{ type: 'spring', stiffness: 300, damping: 30 }}
//                                 className="w-64 md:w-72 lg:w-80 bg-surface-light dark:bg-surface-dark border-r border-gray-200 dark:border-gray-700 overflow-y-auto p-4 shadow-lg flex-shrink-0"
//                             >
//                                 <LeftPanel />
//                             </motion.aside>
//                         )}
//                         </AnimatePresence>

//                         {/* Center Panel */}
//                         <main className="flex-1 flex flex-col overflow-hidden p-2 sm:p-4">
//                            <CenterPanel 
//                                 messages={messages} 
//                                 setMessages={setMessages} 
//                                 currentSessionId={currentSessionId}
//                                 chatStatus={chatStatus}
//                                 setChatStatus={setChatStatus}
//                             />
//                         </main>

//                         {/* Right Panel */}
//                         <AnimatePresence>
//                         {isRightPanelOpen && (
//                             <motion.aside 
//                                 initial={{ x: '100%', opacity: 0 }}
//                                 animate={{ x: '0%', opacity: 1 }}
//                                 exit={{ x: '100%', opacity: 0 }}
//                                 transition={{ type: 'spring', stiffness: 300, damping: 30 }}
//                                 className="w-64 md:w-72 lg:w-80 bg-surface-light dark:bg-surface-dark border-l border-gray-200 dark:border-gray-700 overflow-y-auto p-4 shadow-lg flex-shrink-0"
//                             >
//                                 <RightPanel />
//                             </motion.aside>
//                         )}
//                         </AnimatePresence>
//                     </div>
//                 </>
//             )}
//         </div>
//     );
// }

// export default App;

// import React, { useState, useEffect, useCallback } from 'react';
// import { useAuth } from './hooks/useAuth';
// import { useAppState } from './contexts/AppStateContext';
// import AuthModal from './components/auth/AuthModal';
// import TopNav from './components/layout/TopNav';
// import LeftPanel from './components/layout/LeftPanel';
// import CenterPanel from './components/layout/CenterPanel';
// import RightPanel from './components/layout/RightPanel';
// import api from './services/api';
// import toast from 'react-hot-toast';
// import { motion, AnimatePresence } from 'framer-motion';

// // Match this with AuthContext and AppStateContext for dev mode
// const DEV_MODE_BYPASS_AUTH = true; // Set to true to bypass login and use fake user/session

// function App() {
//     const { token, user, loading: authLoadingFromContext, logout, setUser: setAuthUser, setToken: setAuthToken } = useAuth();
//     const { 
//         theme, 
//         // selectedLLM, // selectedLLM is now managed by LLMSelectionModal and TopNav directly via AppStateContext
//         isLeftPanelOpen, setIsLeftPanelOpen, // Assuming these are still needed for App level control if any
//         isRightPanelOpen, setIsRightPanelOpen, // Or if TopNav manages them via context directly
//         currentSessionId, setSessionId: setGlobalSessionId 
//     } = useAppState();
    
//     // Local loading state for App component's own async operations or initial setup
//     const [appInitializing, setAppInitializing] = useState(true);
//     const [showAuthModal, setShowAuthModal] = useState(false);
//     const [messages, setMessages] = useState([]);
//     const [chatStatus, setChatStatus] = useState('Ready. Send a message to start!');
//     const [orchestratorStatus, setOrchestratorStatus] = useState({ status: "loading", message: "Connecting..." });

//     // Initialize theme
//     useEffect(() => {
//         if (theme === 'dark') {
//             document.documentElement.classList.add('dark');
//         } else {
//             document.documentElement.classList.remove('dark');
//         }
//         // Add/remove theme class from body as well for global styles if needed
//         document.body.className = ''; // Clear previous theme classes
//         document.body.classList.add(theme); // Add current theme class (e.g., 'dark' or 'light')
//     }, [theme]);


//     // Auth and Session Initialization Logic
//     useEffect(() => {
//         if (DEV_MODE_BYPASS_AUTH) {
//             // AuthContext already provides fake token/user if DEV_MODE_BYPASS_AUTH is true in AuthContext.
//             // AppStateContext already provides fake session if DEV_MODE_BYPASS_AUTH is true in AppStateContext.
//             // Here we just ensure App.jsx acknowledges this state.
//             console.log("DEV_MODE: App.jsx recognizing bypassed auth.");
//             if (!currentSessionId) { // If AppStateContext didn't set a dev session, set one here.
//                  setGlobalSessionId('dev-session-appjsx-123');
//             }
//             setAppInitializing(false);
//             setShowAuthModal(false); // Explicitly ensure modal is not shown
//             return;
//         }

//         // Real auth flow
//         if (authLoadingFromContext) {
//             setAppInitializing(true); // Still initializing if AuthContext is loading
//             return;
//         }

//         if (!token) { // No token, needs login
//             setShowAuthModal(true);
//             setAppInitializing(false);
//         } else { // Token exists
//             setShowAuthModal(false);
//             if (!currentSessionId) { // Token exists, but no session ID found
//                 api.startNewSession().then(data => {
//                     setGlobalSessionId(data.sessionId);
//                 }).catch(err => {
//                     toast.error("Failed to start a new session. Please try logging in again.");
//                     console.error(err);
//                     // Consider logging out if session start fails critically
//                     // logout(); 
//                     // setShowAuthModal(true);
//                 });
//             }
//             setAppInitializing(false);
//         }
//     }, [token, authLoadingFromContext, currentSessionId, setGlobalSessionId, logout, setAuthToken, setAuthUser ]);


//     // Fetch orchestrator status
//     useEffect(() => {
//         const fetchStatus = async () => {
//             const statusData = await api.getOrchestratorStatus();
//             setOrchestratorStatus(statusData);
//         };
//         fetchStatus();
//         const intervalId = setInterval(fetchStatus, 20000);
//         return () => clearInterval(intervalId);
//     }, []);

//     // Fetch chat history when session ID or token changes (and both are present)
//     const fetchChatHistory = useCallback(async (sid) => {
//         if (!sid || !token) {
//             setMessages([]);
//             setChatStatus("Login or start a new chat.");
//             return;
//         }
//         setChatStatus("Loading history...");
//         try {
//             const historyData = await api.getChatHistory(sid);
//             const formattedMessages = (Array.isArray(historyData) ? historyData : []).map(msg => ({
//                 id: msg.id || msg._id || String(Math.random()),
//                 sender: msg.role === 'model' ? 'bot' : 'user',
//                 text: msg.parts && msg.parts.length > 0 ? msg.parts[0].text : (msg.text || ''),
//                 thinking: msg.thinking,
//                 references: msg.references || [],
//                 timestamp: msg.timestamp,
//                 source_pipeline: msg.source_pipeline
//             }));
//             setMessages(formattedMessages);
//             setChatStatus(formattedMessages.length > 0 ? "History loaded." : "New chat. Send a message!");
//         } catch (error) {
//             toast.error(`Failed to load chat history: ${error.message}`);
//             setChatStatus("Error loading history.");
//             console.error("Failed to load chat history:", error);
//         }
//     }, [token]); // Removed sid from dependencies to call it explicitly

//     useEffect(() => {
//         if (currentSessionId && token) {
//             fetchChatHistory(currentSessionId);
//         } else if (!token) {
//             setMessages([]); // Clear messages if logged out
//             setChatStatus("Please login.");
//         }
//     }, [currentSessionId, token, fetchChatHistory]);


//     const handleAuthSuccess = (authData) => {
//         setShowAuthModal(false);
//         // AuthContext's login/signup should have set the token and user.
//         // App.js needs to set the session ID obtained from login/signup.
//         if (authData.sessionId) {
//             setGlobalSessionId(authData.sessionId);
//              // Fetch history for this new session
//             fetchChatHistory(authData.sessionId);
//         } else {
//             // If no sessionId from auth, start a new one
//             api.startNewSession().then(data => {
//                 setGlobalSessionId(data.sessionId);
//                 fetchChatHistory(data.sessionId);
//             }).catch(err => toast.error("Failed to initialize session after login."));
//         }
//          // Ensure user object is fully populated in AuthContext if authData has more details
//         if(authData.username && authData._id && authData.token){
//             // setAuthToken(authData.token); // AuthContext should do this from login/signup
//             setAuthUser({username: authData.username, id: authData._id});
//         }
//     };
    
//     const handleLogoutAndShowModal = () => {
//         logout(); // This clears token and user in AuthContext
//         setGlobalSessionId(null); // Clear session in AppStateContext
//         localStorage.removeItem('aiTutorSessionId'); // Explicitly clear from localStorage too
//         setMessages([]);
//         setShowAuthModal(true); // Trigger AuthModal display
//         toast.success("Logged out successfully.");
//     };

//     const handleNewChat = async () => {
//         try {
//             const data = await api.startNewSession();
//             setGlobalSessionId(data.sessionId);
//             setMessages([]);
//             setChatStatus("New chat started. Send a message!");
//             toast.success("New chat started!");
//         } catch (error) {
//             toast.error("Failed to start new chat.");
//             console.error("Failed to start new chat:", error);
//         }
//     };

//     // This is the initial loading state for the entire app before we know if we show AuthModal or main app
//     if (appInitializing && !DEV_MODE_BYPASS_AUTH) { 
//         return (
//             <div className="fixed inset-0 flex items-center justify-center bg-background-light dark:bg-background-dark">
//                 <div className="animate-spin rounded-full h-16 w-16 border-t-4 border-b-4 border-primary"></div>
//                 <p className="ml-4 text-xl text-text-light dark:text-text-dark">Initializing App...</p>
//             </div>
//         );
//     }

//     return (
//         <div className={`flex flex-col h-screen overflow-hidden font-sans ${theme}`}>
//             <AnimatePresence>
//                 {showAuthModal && !token && ( // Show modal only if no token and dev bypass is off
//                     <AuthModal isOpen={showAuthModal} onClose={handleAuthSuccess} />
//                 )}
//             </AnimatePresence>

//             {/* Render main app content if token exists (or dev bypass is on and user is set) */}
//             {(token && user) && (
//                 <>
//                     <TopNav
//                         user={user} // User from AuthContext
//                         onLogout={handleLogoutAndShowModal}
//                         onNewChat={handleNewChat}
//                         onHistoryClick={() => toast.info("History feature coming soon!")}
//                         orchestratorStatus={orchestratorStatus}
//                         // Panel toggle props for TopNav to control App's panel state:
//                         isLeftPanelOpen={isLeftPanelOpen}
//                         toggleLeftPanel={() => setIsLeftPanelOpen(prev => !prev)}
//                         isRightPanelOpen={isRightPanelOpen}
//                         toggleRightPanel={() => setIsRightPanelOpen(prev => !prev)}
//                     />
//                     <div className="flex flex-1 overflow-hidden pt-16"> {/* pt-16 for fixed TopNav height */}
//                         <AnimatePresence>
//                         {isLeftPanelOpen && (
//                             <motion.aside 
//                                 key="left-panel"
//                                 initial={{ x: '-100%', opacity: 0 }}
//                                 animate={{ x: '0%', opacity: 1 }}
//                                 exit={{ x: '-100%', opacity: 0 }}
//                                 transition={{ type: 'spring', stiffness: 260, damping: 30 }}
//                                 className="w-full md:w-72 lg:w-80 xl:w-96 bg-surface-light dark:bg-surface-dark border-r border-gray-200 dark:border-gray-700 overflow-y-auto p-3 sm:p-4 shadow-lg flex-shrink-0 custom-scrollbar"
//                             >
//                                 <LeftPanel />
//                             </motion.aside>
//                         )}
//                         </AnimatePresence>

//                         <main className="flex-1 flex flex-col overflow-hidden p-1 sm:p-2 md:p-4">
//                            <CenterPanel 
//                                 messages={messages} 
//                                 setMessages={setMessages} 
//                                 currentSessionId={currentSessionId}
//                                 chatStatus={chatStatus}
//                                 setChatStatus={setChatStatus}
//                             />
//                         </main>

//                         <AnimatePresence>
//                         {isRightPanelOpen && (
//                             <motion.aside 
//                                 key="right-panel"
//                                 initial={{ x: '100%', opacity: 0 }}
//                                 animate={{ x: '0%', opacity: 1 }}
//                                 exit={{ x: '100%', opacity: 0 }}
//                                 transition={{ type: 'spring', stiffness: 260, damping: 30 }}
//                                 className="hidden md:block md:w-72 lg:w-80 xl:w-96 bg-surface-light dark:bg-surface-dark border-l border-gray-200 dark:border-gray-700 overflow-y-auto p-3 sm:p-4 shadow-lg flex-shrink-0 custom-scrollbar"
//                             >
//                                 <RightPanel />
//                             </motion.aside>
//                         )}
//                         </AnimatePresence>
//                     </div>
//                 </>
//             )}
//         </div>
//     );
// }

// export default App;

// import React, { useState, useEffect, useCallback } from 'react';
// import { useAuth } from './hooks/useAuth';
// import { useAppState } from './contexts/AppStateContext';
// import AuthModal from './components/auth/AuthModal';
// import TopNav from './components/layout/TopNav';
// import LeftPanel from './components/layout/LeftPanel';
// import CenterPanel from './components/layout/CenterPanel';
// import RightPanel from './components/layout/RightPanel';
// import api from './services/api';
// import toast from 'react-hot-toast';
// import { motion, AnimatePresence } from 'framer-motion';

// // Match this with AuthContext and AppStateContext for dev mode
// const DEV_MODE_BYPASS_AUTH = true; 

// function App() {
//     const { token, user, loading: authLoadingFromContext, logout, setUser: setAuthUser } = useAuth();
//     const { 
//         theme, 
//         isLeftPanelOpen, // Only need to read from context for rendering
//         isRightPanelOpen, // Only need to read from context for rendering
//         currentSessionId, setSessionId: setGlobalSessionId 
//     } = useAppState();
    
//     const [appInitializing, setAppInitializing] = useState(true);
//     const [showAuthModal, setShowAuthModal] = useState(false);
//     const [messages, setMessages] = useState([]);
//     const [chatStatus, setChatStatus] = useState('Ready. Send a message to start!');
//     const [orchestratorStatus, setOrchestratorStatus] = useState({ status: "loading", message: "Connecting..." });

//     // Initialize theme class on <html> and <body>
//     useEffect(() => {
//         const root = document.documentElement;
//         const body = document.body;
//         if (theme === 'dark') {
//             root.classList.add('dark');
//             body.classList.add('dark'); // Optional: if body needs explicit dark class
//             body.classList.remove('light');
//         } else {
//             root.classList.remove('dark');
//             body.classList.add('light'); // Optional
//             body.classList.remove('dark');
//         }
//     }, [theme]);

//     // Auth and Session Initialization Logic
//     useEffect(() => {
//         if (DEV_MODE_BYPASS_AUTH) {
//             console.log("DEV_MODE: App.jsx recognizing bypassed auth.");
//             if (!currentSessionId && user) { // Ensure session is set if user is dev-mode set
//                  setGlobalSessionId('dev-session-appjsx-123');
//             }
//             setAppInitializing(false);
//             setShowAuthModal(false);
//             return;
//         }

//         if (authLoadingFromContext) {
//             setAppInitializing(true);
//             return;
//         }

//         if (!token) {
//             setShowAuthModal(true);
//             setAppInitializing(false);
//         } else {
//             setShowAuthModal(false);
//             if (!currentSessionId) {
//                 api.startNewSession().then(data => {
//                     setGlobalSessionId(data.sessionId);
//                 }).catch(err => {
//                     toast.error("Session init failed. Try login.");
//                     console.error(err);
//                     // logout(); // Consider forcing logout if session init is critical
//                 });
//             }
//             setAppInitializing(false);
//         }
//     }, [token, user, authLoadingFromContext, currentSessionId, setGlobalSessionId, logout]);

//     // Fetch orchestrator status
//     useEffect(() => {
//         const fetchStatus = async () => {
//             const statusData = await api.getOrchestratorStatus();
//             setOrchestratorStatus(statusData);
//         };
//         fetchStatus();
//         const intervalId = setInterval(fetchStatus, 20000);
//         return () => clearInterval(intervalId);
//     }, []);

//     // Fetch chat history
//     const fetchChatHistory = useCallback(async (sid) => {
//         if (!sid || !token) {
//             setMessages([]);
//             setChatStatus(token ? "Start a new chat or select one." : "Please login.");
//             return;
//         }
//         setChatStatus("Loading history...");
//         try {
//             const historyData = await api.getChatHistory(sid);
//             const formattedMessages = (Array.isArray(historyData) ? historyData : []).map(msg => ({
//                 id: msg.id || msg._id || String(Math.random()),
//                 sender: msg.role === 'model' ? 'bot' : 'user',
//                 text: msg.parts && msg.parts.length > 0 ? msg.parts[0].text : (msg.text || ''),
//                 thinking: msg.thinking,
//                 references: msg.references || [],
//                 timestamp: msg.timestamp,
//                 source_pipeline: msg.source_pipeline
//             }));
//             setMessages(formattedMessages);
//             setChatStatus(formattedMessages.length > 0 ? "History loaded." : "New chat. Send a message!");
//         } catch (error) {
//             toast.error(`Failed to load chat history: ${error.message}`);
//             setChatStatus("Error loading history.");
//             console.error("Failed to load chat history:", error);
//         }
//     }, [token]); // Dependency on token

//     useEffect(() => {
//         if (currentSessionId && token) {
//             fetchChatHistory(currentSessionId);
//         } else if (!token) {
//             setMessages([]);
//             setChatStatus("Please login.");
//         }
//     }, [currentSessionId, token, fetchChatHistory]);

//     const handleAuthSuccess = (authData) => {
//         setShowAuthModal(false);
//         if (authData.sessionId) {
//             setGlobalSessionId(authData.sessionId);
//             fetchChatHistory(authData.sessionId); // Fetch history for newly assigned session
//         } else {
//             api.startNewSession().then(data => { // Fallback to start new session
//                 setGlobalSessionId(data.sessionId);
//                 fetchChatHistory(data.sessionId);
//             }).catch(err => toast.error("Failed to initialize session after login."));
//         }
//         if(authData.username && authData._id){ // Ensure user in AuthContext is updated
//             setAuthUser({username: authData.username, id: authData._id});
//         }
//     };
    
//     const handleLogoutAndShowModal = () => {
//         logout(); 
//         setGlobalSessionId(null);
//         localStorage.removeItem('aiTutorSessionId'); 
//         setMessages([]);
//         if (!DEV_MODE_BYPASS_AUTH) { // Only show modal if not in full bypass mode
//              setShowAuthModal(true); 
//         } else {
//             // In full bypass, logout might mean 'clear dev state and show modal anyway'
//             // Or, to truly "logout" from dev mode, user would change the DEV_MODE_BYPASS_AUTH flag and refresh.
//             // For a UI-testable "logout" in dev mode that shows the modal:
//             // setAuthUser(null); // This would make the `token && user` condition false
//             // setAuthToken(null); // This would make the `token && user` condition false
//             // setShowAuthModal(true); // This is now handled by the useEffect
//              console.log("DEV_MODE: Logged out. Set DEV_MODE_BYPASS_AUTH=false and refresh to see AuthModal, or handle dev logout differently.");
//         }
//         toast.success("Logged out successfully.");
//     };

//     const handleNewChat = async () => {
//         try {
//             const data = await api.startNewSession();
//             setGlobalSessionId(data.sessionId); // This will trigger useEffect to fetch history (empty)
//             setMessages([]); // Explicitly clear messages for immediate UI update
//             setChatStatus("New chat started. Send a message!");
//             toast.success("New chat started!");
//         } catch (error) {
//             toast.error("Failed to start new chat.");
//             console.error("Failed to start new chat:", error);
//         }
//     };

//     if (appInitializing && (!DEV_MODE_BYPASS_AUTH || authLoadingFromContext)) { 
//         return (
//             <div className="fixed inset-0 flex flex-col items-center justify-center bg-background-light dark:bg-background-dark text-text-light dark:text-text-dark">
//                 <div className="animate-spin rounded-full h-12 w-12 border-t-4 border-b-4 border-primary mb-4"></div>
//                 <p className="text-xl">Initializing AI Tutor...</p>
//             </div>
//         );
//     }

//     return (
//         <div className={`flex flex-col h-screen overflow-hidden font-sans ${theme}`}>
//             <AnimatePresence>
//                 {showAuthModal && !token && (
//                     <AuthModal isOpen={showAuthModal} onClose={handleAuthSuccess} />
//                 )}
//             </AnimatePresence>

//             {(token && user) && ( // Main application UI rendered if authenticated
//                 <>
//                     <TopNav
//                         user={user}
//                         onLogout={handleLogoutAndShowModal}
//                         onNewChat={handleNewChat}
//                         onHistoryClick={() => toast.info("History feature coming soon!")}
//                         orchestratorStatus={orchestratorStatus}
//                         // TopNav now uses useAppState for panel toggles, so no props needed here for that
//                     />
//                     <div className="flex flex-1 overflow-hidden pt-16 bg-background-light dark:bg-background-dark"> {/* pt-16 for fixed TopNav height */}
//                         <AnimatePresence>
//                         {isLeftPanelOpen && (
//                             <motion.aside 
//                                 key="left-panel"
//                                 initial={{ x: '-100%', opacity: 0 }}
//                                 animate={{ x: '0%', opacity: 1 }}
//                                 exit={{ x: '-100%', opacity: 0 }}
//                                 transition={{ type: 'spring', stiffness: 260, damping: 30, duration: 0.3 }}
//                                 className="w-full md:w-72 lg:w-80 xl:w-96 bg-surface-light dark:bg-surface-dark border-r border-gray-200 dark:border-gray-700 overflow-y-auto p-3 sm:p-4 shadow-lg flex-shrink-0 custom-scrollbar"
//                             >
//                                 <LeftPanel />
//                             </motion.aside>
//                         )}
//                         </AnimatePresence>

//                         <main className="flex-1 flex flex-col overflow-hidden p-1 sm:p-2 md:p-4">
//                            <CenterPanel 
//                                 messages={messages} 
//                                 setMessages={setMessages} 
//                                 currentSessionId={currentSessionId}
//                                 chatStatus={chatStatus}
//                                 setChatStatus={setChatStatus}
//                             />
//                         </main>

//                         <AnimatePresence>
//                         {isRightPanelOpen && (
//                             <motion.aside 
//                                 key="right-panel"
//                                 initial={{ x: '100%', opacity: 0 }}
//                                 animate={{ x: '0%', opacity: 1 }}
//                                 exit={{ x: '100%', opacity: 0 }}
//                                 transition={{ type: 'spring', stiffness: 260, damping: 30, duration: 0.3 }}
//                                 className="hidden md:block md:w-72 lg:w-80 xl:w-96 bg-surface-light dark:bg-surface-dark border-l border-gray-200 dark:border-gray-700 overflow-y-auto p-3 sm:p-4 shadow-lg flex-shrink-0 custom-scrollbar"
//                             >
//                                 <RightPanel />
//                             </motion.aside>
//                         )}
//                         </AnimatePresence>
//                     </div>
//                 </>
//             )}
//             {/* Fallback if not loading and not authenticated (and not in dev bypass mode) */}
//             { !appInitializing && !token && !DEV_MODE_BYPASS_AUTH && !showAuthModal && (
//                  <div className="fixed inset-0 flex flex-col items-center justify-center bg-background-light dark:bg-background-dark text-text-light dark:text-text-dark">
//                      <p className="text-xl">Please <button onClick={()=> setShowAuthModal(true)} className="text-primary underline">log in</button> to continue.</p>
//                  </div>
//             )}
//         </div>
//     );
// }

// export default App;

// import React, { useState, useEffect, useCallback } from 'react';
// import { useAuth } from './hooks/useAuth';
// import { useAppState } from './contexts/AppStateContext';
// import AuthModal from './components/auth/AuthModal';
// import TopNav from './components/layout/TopNav';
// // ... other imports ...
// import toast from 'react-hot-toast';
// // ...

// // Set this to FALSE if you want to see the AuthModal first
// // const DEV_MODE_BYPASS_AUTH = false; // Or remove this App.jsx specific flag

// function App() {
//     // Get DEV_MODE_ALLOW_DEV_LOGIN from AuthContext if you want to use it for other dev features
//     const { token, user, loading: authLoading, logout, setUser: setAuthUser, DEV_MODE_ALLOW_DEV_LOGIN } = useAuth(); 
//     const { 
//         theme, 
//         isLeftPanelOpen, isRightPanelOpen, 
//         currentSessionId, setSessionId: setGlobalSessionId 
//     } = useAppState();
    
//     const [appInitializing, setAppInitializing] = useState(true); // Still useful for initial data fetches
//     const [showAuthModal, setShowAuthModal] = useState(false);
//     // ... other states ...

//     // Theme initialization (as before)
//     useEffect(() => { /* ... */ }, [theme]);

//     // Auth and Session Initialization Logic
//     useEffect(() => {
//         // This effect now primarily handles showing the auth modal if not authenticated,
//         // and initializing session if authenticated.
//         if (authLoading) { // If AuthContext is still figuring out token/user
//             setAppInitializing(true);
//             return;
//         }

//         if (!token) { // No token means user is not logged in
//             setShowAuthModal(true);
//             setAppInitializing(false);
//         } else { // Token exists, user is considered logged in
//             setShowAuthModal(false); // Ensure modal is closed
//             // If user is logged in but no session ID exists, try to start one
//             if (!currentSessionId) { 
//                 api.startNewSession().then(data => {
//                     setGlobalSessionId(data.sessionId);
//                 }).catch(err => {
//                     toast.error("Session init failed. Try login.");
//                     console.error(err);
//                 });
//             }
//             setAppInitializing(false);
//         }
//     }, [token, authLoading, currentSessionId, setGlobalSessionId]);

//     // ... (fetchOrchestratorStatus, fetchChatHistory as before) ...

//     const handleAuthSuccess = (authData) => {
//         // This function is called by AuthModal on successful login/signup/devLogin
//         setShowAuthModal(false);
//         // AuthContext should have already updated token and user.
//         // App.jsx just needs to handle the sessionId.
//         if (authData && authData.sessionId) {
//             setGlobalSessionId(authData.sessionId);
//             // fetchChatHistory will be triggered by useEffect watching currentSessionId & token
//         } else if (token) { // If authData didn't provide sessionId but we are now logged in
//              api.startNewSession().then(data => {
//                 setGlobalSessionId(data.sessionId);
//             }).catch(err => toast.error("Failed to init session."));
//         }
//          // Update user in AuthContext if authData provides more details than parseToken
//         if(authData && authData.username && authData._id && token){ // Ensure token is also set
//             setAuthUser({username: authData.username, id: authData._id});
//         }
//     };
    
//     const handleLogoutAndShowModal = () => {
//         logout(); 
//         setGlobalSessionId(null);
//         localStorage.removeItem('aiTutorSessionId'); 
//         setMessages([]);
//         setShowAuthModal(true); // Explicitly show modal after logout
//         toast.success("Logged out successfully.");
//     };

//     // ... (handleNewChat as before) ...

//     // Initial App Loader
//     if (appInitializing) { 
//         return ( /* ... loading spinner as before ... */ );
//     }

//     return (
//         <div className={`flex flex-col h-screen overflow-hidden font-sans ${theme}`}>
//             <AnimatePresence>
//                 {showAuthModal && !token && ( // Show modal if flag is true AND no token
//                     <AuthModal 
//                         isOpen={showAuthModal} 
//                         onClose={handleAuthSuccess} // Pass a callback to close modal & update state
//                     />
//                 )}
//             </AnimatePresence>

//             {(token && user) && ( // Main application UI
//                 <>
//                     {/* ... TopNav, Panels as before ... */}
//                 </>
//             )}
//             {/* Fallback if not loading, no token, and modal isn't showing (should be rare) */}
//             {!appInitializing && !token && !showAuthModal && (
//                  <div className="fixed inset-0 flex items-center justify-center">
//                      <p>Please <button onClick={()=> {
//                          setShowAuthModal(true);
//                          // Also ensure AppStateContext dev session is cleared if we are showing login
//                          if (DEV_MODE_ALLOW_DEV_LOGIN && currentSessionId && currentSessionId.startsWith('dev-session')) {
//                             setGlobalSessionId(null);
//                          }
//                         }} className="text-primary underline">log in</button> to continue.</p>
//                  </div>
//             )}
//         </div>
//     );
// }

// export default App;

// import React, { useState, useEffect, useCallback } from 'react';
// import { useAuth } from './hooks/useAuth';
// import { useAppState } from './contexts/AppStateContext';
// import AuthModal from './components/auth/AuthModal';
// import TopNav from './components/layout/TopNav';
// import LeftPanel from './components/layout/LeftPanel';
// import CenterPanel from './components/layout/CenterPanel';
// import RightPanel from './components/layout/RightPanel';
// import api from './services/api';
// import toast from 'react-hot-toast';
// import { motion, AnimatePresence } from 'framer-motion';

// // Set this consistently across AuthContext, AppStateContext, and App.jsx for dev mode
// const DEV_MODE_BYPASS_AUTH = true; 

// function App() {
//     const { 
//         token, 
//         user, 
//         loading: authLoadingFromContext, 
//         logout, 
//         setUser: setAuthUser, 
//         // setToken: setAuthToken // We usually let AuthContext manage token setting via login/logout
//     } = useAuth();

//     const { 
//         theme, 
//         isLeftPanelOpen, // AppStateContext manages this state
//         isRightPanelOpen, // AppStateContext manages this state
//         currentSessionId, 
//         setSessionId: setGlobalSessionId 
//     } = useAppState();
    
//     // Local loading state for App component's own async operations or initial setup
//     const [appInitializing, setAppInitializing] = useState(true);
//     const [showAuthModal, setShowAuthModal] = useState(false); // Controls AuthModal visibility
//     const [messages, setMessages] = useState([]);
//     const [chatStatus, setChatStatus] = useState('Ready. Send a message to start!');
//     const [orchestratorStatus, setOrchestratorStatus] = useState({ status: "loading", message: "Connecting..." });

//     // Initialize theme class on <html> and <body>
//     useEffect(() => {
//         const rootHtmlElement = document.documentElement;
//         const bodyElement = document.body; // If you need body-specific classes too
//         if (theme === 'dark') {
//             rootHtmlElement.classList.add('dark');
//             // bodyElement.classList.add('dark-theme-body'); // Example
//         } else {
//             rootHtmlElement.classList.remove('dark');
//             // bodyElement.classList.remove('dark-theme-body');
//         }
//         // For more complex body theming, you might set a data-theme attribute
//         // bodyElement.setAttribute('data-theme', theme);
//     }, [theme]);


//     // Auth and Session Initialization Logic
//     useEffect(() => {
//         if (DEV_MODE_BYPASS_AUTH) {
//             // In dev bypass mode, AuthContext and AppStateContext should already provide
//             // devUser, devToken, and devSessionId.
//             // App.jsx just needs to ensure it's not stuck in an initializing state.
//             console.log("DEV_MODE (App.jsx): Bypassing auth, user/token should be set by AuthContext.");
//             if (user && token && !currentSessionId) { // If dev user/token set, but no dev session
//                  setGlobalSessionId('dev-session-appjsx-ensure-123'); // Ensure a session ID
//             }
//             setAppInitializing(false); // Bypass complete
//             setShowAuthModal(false);   // Don't show auth modal
//             return;
//         }

//         // Real auth flow (if DEV_MODE_BYPASS_AUTH is false)
//         if (authLoadingFromContext) {
//             setAppInitializing(true); // Still initializing if AuthContext is checking token
//             return;
//         }

//         if (!token) { // No token means user is not logged in (AuthContext confirmed this)
//             setShowAuthModal(true);   // Prompt for login/signup
//             setAppInitializing(false);
//         } else { // Token exists, user is considered logged in
//             setShowAuthModal(false); // Ensure modal is closed
//             if (!currentSessionId) { // Token exists, but no session ID found in AppStateContext
//                 api.startNewSession().then(data => {
//                     setGlobalSessionId(data.sessionId);
//                 }).catch(err => {
//                     toast.error("Session initialization failed. Please try logging in again.");
//                     console.error("Session init error after token check:", err);
//                     // Consider if logout is needed here if session is critical
//                     // logout(); 
//                 });
//             }
//             setAppInitializing(false); // Done initializing for authenticated user
//         }
//     }, [token, user, authLoadingFromContext, currentSessionId, setGlobalSessionId, logout]);


//     // Fetch orchestrator status (runs regardless of auth state for general app health)
//     useEffect(() => {
//         const fetchStatus = async () => {
//             const statusData = await api.getOrchestratorStatus();
//             setOrchestratorStatus(statusData);
//         };
//         fetchStatus();
//         const intervalId = setInterval(fetchStatus, 20000); // Check every 20 seconds
//         return () => clearInterval(intervalId);
//     }, []);

//     // Fetch chat history when session ID or token changes (and both are present)
//     const fetchChatHistory = useCallback(async (sid) => {
//         if (!sid || !token) { // Need both session and token
//             setMessages([]);
//             setChatStatus(token ? "Start or select a chat." : "Please login to see chat history.");
//             return;
//         }
//         setChatStatus("Loading history...");
//         try {
//             const historyData = await api.getChatHistory(sid); // Token auto-included by API service
//             const formattedMessages = (Array.isArray(historyData) ? historyData : []).map(msg => ({
//                 id: msg.id || msg._id || String(Math.random() + Date.now()), // Ensure unique key
//                 sender: msg.role === 'model' ? 'bot' : 'user',
//                 text: msg.parts && msg.parts.length > 0 ? msg.parts[0].text : (msg.text || ''),
//                 thinking: msg.thinking,
//                 references: msg.references || [],
//                 timestamp: msg.timestamp,
//                 source_pipeline: msg.source_pipeline
//             }));
//             setMessages(formattedMessages);
//             setChatStatus(formattedMessages.length > 0 ? "History loaded." : "Chat is empty. Send a message!");
//         } catch (error) {
//             toast.error(`Failed to load chat history: ${error.message}`);
//             setChatStatus("Error loading history.");
//             console.error("Failed to load chat history:", error);
//         }
//     }, [token]); // Depends on token to make the API call

//     useEffect(() => {
//         // This effect runs when currentSessionId or token changes.
//         // It calls fetchChatHistory if both are present.
//         if (currentSessionId && token) {
//             fetchChatHistory(currentSessionId);
//         } else if (!token) { // If token becomes null (e.g., after logout)
//             setMessages([]); // Clear messages
//             setChatStatus("Please login.");
//         }
//         // If token exists but currentSessionId is null, the auth useEffect should handle starting a new session
//     }, [currentSessionId, token, fetchChatHistory]);


//     const handleAuthSuccess = (authData) => { // Called by AuthModal after successful login/signup/devLogin
//         setShowAuthModal(false);
//         // AuthContext's login/signup/devLogin methods should have set the token and user in AuthContext.
//         // App.jsx uses the `user` and `token` from `useAuth()`.
//         // The main task here is to ensure the session ID from authData is set globally.
//         if (authData && authData.sessionId) {
//             setGlobalSessionId(authData.sessionId);
//             // fetchChatHistory will be triggered by the useEffect watching currentSessionId & token
//         } else if (token) { 
//             // Fallback: if authData didn't give a sessionId but we are now logged in (token exists)
//             console.warn("Auth success but no sessionId in authData, starting new session.");
//             api.startNewSession().then(data => {
//                 setGlobalSessionId(data.sessionId);
//             }).catch(err => toast.error("Failed to initialize session."));
//         }
//         // If authData contains more complete user details than what parseToken in AuthContext provides:
//         if(authData && authData.username && authData._id){
//             setAuthUser({username: authData.username, id: authData._id}); // Update user in AuthContext
//         }
//     };
    
//     const handleLogoutAndShowModal = () => {
//         logout(); // Clears token and user in AuthContext
//         setGlobalSessionId(null); // Clears session in AppStateContext
//         localStorage.removeItem('aiTutorSessionId'); // Explicitly clear from localStorage
//         setMessages([]);
//         setChatStatus("Logged out. Please login.");
//         if (!DEV_MODE_BYPASS_AUTH) { // Only force modal if not in full bypass
//              setShowAuthModal(true); 
//         } else {
//             // To test the modal even in dev mode after a "dev logout", you could manually set showAuthModal.
//             // However, the primary way to see AuthModal in dev mode is to set DEV_MODE_BYPASS_AUTH = false in relevant contexts.
//             console.log("DEV_MODE: Logged out. To see AuthModal, set DEV_MODE_BYPASS_AUTH=false and refresh, or handle dev logout differently.");
//             // For testing purposes, if you want a "dev logout" to always show the modal:
//             // setShowAuthModal(true); 
//         }
//         toast.success("Logged out successfully.");
//     };

//     const handleNewChat = async () => {
//         try {
//             const data = await api.startNewSession();
//             setGlobalSessionId(data.sessionId); // This will trigger useEffect to fetch history (which will be empty)
//             setMessages([]); // Explicitly clear messages for immediate UI update
//             setChatStatus("New chat started. Send a message!");
//             toast.success("New chat started!");
//         } catch (error) {
//             toast.error("Failed to start new chat.");
//             console.error("Failed to start new chat:", error);
//         }
//     };

//     // Initial App Loader (Handles both AuthContext loading and DEV_MODE_BYPASS_AUTH logic)
//     if (appInitializing) { 
//         return (
//             <div className="fixed inset-0 flex flex-col items-center justify-center bg-background-light dark:bg-background-dark text-text-light dark:text-text-dark">
//                 <div className="animate-spin rounded-full h-12 w-12 border-t-4 border-b-4 border-primary mb-4"></div>
//                 <p className="text-xl">Initializing AI Tutor...</p>
//             </div>
//         );
//     }

//     return (
//         <div className={`flex flex-col h-screen overflow-hidden font-sans ${theme}`}> {/* Theme class applied here */}
//             <AnimatePresence>
//                 {showAuthModal && !token && ( // Show AuthModal if needed and not authenticated
//                     <AuthModal 
//                         isOpen={showAuthModal} 
//                         onClose={handleAuthSuccess} 
//                     />
//                 )}
//             </AnimatePresence>

//             {/* Main application UI rendered if authenticated (token and user exist) */}
//             {(token && user) && (
//                 <>
//                     <TopNav
//                         user={user} // User from AuthContext
//                         onLogout={handleLogoutAndShowModal}
//                         onNewChat={handleNewChat}
//                         onHistoryClick={() => toast.info("History feature coming soon!")}
//                         orchestratorStatus={orchestratorStatus}
//                         // Panel toggles are handled by TopNav itself using AppStateContext
//                     />
//                     <div className="flex flex-1 overflow-hidden pt-16 bg-background-light dark:bg-background-dark"> {/* pt-16 for fixed TopNav */}
//                         <AnimatePresence>
//                         {isLeftPanelOpen && (
//                             <motion.aside 
//                                 key="left-panel"
//                                 initial={{ x: '-100%', opacity: 0 }}
//                                 animate={{ x: '0%', opacity: 1 }}
//                                 exit={{ x: '-100%', opacity: 0 }}
//                                 transition={{ type: 'spring', stiffness: 260, damping: 30, duration: 0.3 }}
//                                 className="w-full md:w-72 lg:w-80 xl:w-96 bg-surface-light dark:bg-surface-dark border-r border-gray-200 dark:border-gray-700 overflow-y-auto p-3 sm:p-4 shadow-lg flex-shrink-0 custom-scrollbar"
//                             >
//                                 <LeftPanel />
//                             </motion.aside>
//                         )}
//                         </AnimatePresence>

//                         <main className="flex-1 flex flex-col overflow-hidden p-1 sm:p-2 md:p-4">
//                            <CenterPanel 
//                                 messages={messages} 
//                                 setMessages={setMessages} 
//                                 currentSessionId={currentSessionId}
//                                 chatStatus={chatStatus}
//                                 setChatStatus={setChatStatus}
//                             />
//                         </main>

//                         <AnimatePresence>
//                         {isRightPanelOpen && (
//                             <motion.aside 
//                                 key="right-panel"
//                                 initial={{ x: '100%', opacity: 0 }}
//                                 animate={{ x: '0%', opacity: 1 }}
//                                 exit={{ x: '100%', opacity: 0 }}
//                                 transition={{ type: 'spring', stiffness: 260, damping: 30, duration: 0.3 }}
//                                 className="hidden md:block md:w-72 lg:w-80 xl:w-96 bg-surface-light dark:bg-surface-dark border-l border-gray-200 dark:border-gray-700 overflow-y-auto p-3 sm:p-4 shadow-lg flex-shrink-0 custom-scrollbar"
//                             >
//                                 <RightPanel />
//                             </motion.aside>
//                         )}
//                         </AnimatePresence>
//                     </div>
//                 </>
//             )}
            
//             {/* Fallback UI if not initializing, not authenticated, and AuthModal isn't shown (should be rare) */}
//             { !appInitializing && !token && !showAuthModal && (
//                  <div className="fixed inset-0 flex flex-col items-center justify-center bg-background-light dark:bg-background-dark text-text-light dark:text-text-dark">
//                      <p className="text-xl">Please <button 
//                         onClick={()=> { setShowAuthModal(true); }} 
//                         className="text-primary hover:underline font-semibold"
//                         >log in</button> to continue.</p>
//                  </div>
//             )}
//         </div>
//     );
// }

// export default App;











import React, { useState, useEffect, useCallback } from 'react';
import { useAuth } from './hooks/useAuth';
import { useAppState } from './contexts/AppStateContext';
import AuthModal from './components/auth/AuthModal.jsx';
import TopNav from './components/layout/TopNav.jsx';
import LeftPanel from './components/layout/LeftPanel.jsx';
import CenterPanel from './components/layout/CenterPanel.jsx';
import RightPanel from './components/layout/RightPanel.jsx';
// If you decided AGAINST collapsed navs, these imports should be removed.
// If you WANT them, ensure the files exist and these imports are correct.
// import LeftCollapsedNav from './components/layout/LeftCollapsedNav.jsx';   
// import RightCollapsedNav from './components/layout/RightCollapsedNav.jsx'; 
import ChatHistoryModal from './components/chat/ChatHistoryModal.jsx';
import api from './services/api';
import toast from 'react-hot-toast';
import { motion, AnimatePresence } from 'framer-motion';


function App() {
    const { 
        token, 
        user, 
        loading: authLoadingFromContext, 
        logout, 
        setUser: setAuthUser, 
    } = useAuth();

    const { 
        theme, 
        isLeftPanelOpen, 
        isRightPanelOpen, 
        currentSessionId, 
        setSessionId: setGlobalSessionId 
    } = useAppState();
    
    const [appInitializing, setAppInitializing] = useState(true);
    const [showAuthModal, setShowAuthModal] = useState(false);
    const [messages, setMessages] = useState([]);
    const [chatStatus, setChatStatus] = useState('Ready. Send a message to start!');
    const [orchestratorStatus, setOrchestratorStatus] = useState({ status: "loading", message: "Connecting..." });
    const [isHistoryModalOpen, setIsHistoryModalOpen] = useState(false);

    console.log("App.jsx: Top level render. Token:", token, "User:", user, "authLoadingFromContext:", authLoadingFromContext, "appInitializing:", appInitializing);

    useEffect(() => {
        const rootHtmlElement = document.documentElement;
        if (theme === 'dark') {
            rootHtmlElement.classList.add('dark');
        } else {
            rootHtmlElement.classList.remove('dark');
        }
        console.log("App.jsx: Theme effect, theme is:", theme);
    }, [theme]);

    useEffect(() => {
        console.log("App.jsx: Auth/Session useEffect triggered. authLoadingFromContext:", authLoadingFromContext, "Token:", token, "User:", user, "currentSessionId:", currentSessionId);
        if (authLoadingFromContext) {
            console.log("App.jsx: AuthContext still loading. Setting appInitializing = true.");
            setAppInitializing(true);
            return;
        }

        // AuthContext has finished loading.
        console.log("App.jsx: AuthContext finished loading.");
        if (!token) { 
            console.log("App.jsx: No token found. Setting showAuthModal = true, appInitializing = false.");
            setShowAuthModal(true);
            setAppInitializing(false);
        } else { 
            console.log("App.jsx: Token found. Setting showAuthModal = false.");
            setShowAuthModal(false); 
            if (user && !currentSessionId) { 
                console.log("App.jsx: User exists but no currentSessionId. Attempting to start new session.");
                api.startNewSession().then(data => {
                    console.log("App.jsx: New session started, sessionId:", data.sessionId);
                    setGlobalSessionId(data.sessionId);
                }).catch(err => {
                    toast.error("Session initialization failed. Please try logging in again.");
                    console.error("App.jsx: Session init error after token check:", err);
                });
            } else if (!user) {
                console.warn("App.jsx: Token exists but user object is null. This might indicate an issue with token parsing in AuthContext or backend JWT structure.");
            }
            console.log("App.jsx: Setting appInitializing = false (user authenticated or flow decided).");
            setAppInitializing(false);
        }
    }, [token, user, authLoadingFromContext, currentSessionId, setGlobalSessionId]);


    useEffect(() => {
        console.log("App.jsx: Orchestrator status effect triggered.");
        const fetchStatus = async () => {
            const statusData = await api.getOrchestratorStatus();
            setOrchestratorStatus(statusData);
            console.log("App.jsx: Orchestrator status fetched:", statusData);
        };
        fetchStatus();
        const intervalId = setInterval(fetchStatus, 20000);
        return () => clearInterval(intervalId);
    }, []);

    const fetchChatHistory = useCallback(async (sid) => {
        console.log("App.jsx: fetchChatHistory called for session:", sid, "Token:", token ? "present" : "absent");
        if (!sid || !token) {
            setMessages([]);
            setChatStatus(token ? "Start or select a chat." : "Please login to see chat history.");
            return;
        }
        setChatStatus("Loading history...");
        try {
            const historyData = await api.getChatHistory(sid);
            console.log("App.jsx: Fetched chat history data:", historyData);
            const formattedMessages = (Array.isArray(historyData) ? historyData : []).map(msg => ({
                id: msg.id || msg._id || String(Math.random() + Date.now()),
                sender: msg.role === 'model' ? 'bot' : 'user',
                text: msg.parts && msg.parts.length > 0 ? msg.parts[0].text : (msg.text || ''),
                thinking: msg.thinking,
                references: msg.references || [],
                timestamp: msg.timestamp,
                source_pipeline: msg.source_pipeline
            }));
            setMessages(formattedMessages);
            setChatStatus(formattedMessages.length > 0 ? "History loaded." : "Chat is empty. Send a message!");
        } catch (error) {
            toast.error(`Failed to load chat history: ${error.message}`);
            setChatStatus("Error loading history.");
            console.error("App.jsx: Failed to load chat history:", error);
        }
    }, [token]); 

    useEffect(() => {
        console.log("App.jsx: Chat history trigger useEffect. currentSessionId:", currentSessionId, "Token:", token ? "present" : "absent");
        if (currentSessionId && token) {
            fetchChatHistory(currentSessionId);
        } else if (!token) {
            setMessages([]);
            setChatStatus("Please login.");
        }
    }, [currentSessionId, token, fetchChatHistory]);

    const handleAuthSuccess = (authData) => {
        console.log("App.jsx: handleAuthSuccess called with data:", authData);
        setShowAuthModal(false);
        if (authData && authData.sessionId) {
            setGlobalSessionId(authData.sessionId);
        } else if (token) { 
            console.warn("App.jsx handleAuthSuccess: Auth successful but no sessionId in authData, starting new session as fallback.");
            api.startNewSession().then(data => {
                setGlobalSessionId(data.sessionId);
            }).catch(err => toast.error("Failed to initialize session."));
        }
        if(authData && authData.username && authData._id){ // Ensure AuthContext's user is also updated if more detail comes from backend
            setAuthUser({username: authData.username, id: authData._id}); 
        }
    };
    
    const handleLogoutAndShowModal = () => {
        console.log("App.jsx: handleLogoutAndShowModal called.");
        logout(); 
        setGlobalSessionId(null);
        localStorage.removeItem('aiTutorSessionId'); 
        setMessages([]);
        setChatStatus("Logged out. Please login.");
        setShowAuthModal(true); 
        toast.success("Logged out successfully.");
    };

    const handleNewChat = async () => {
        console.log("App.jsx: handleNewChat called.");
        try {
            const data = await api.startNewSession();
            setGlobalSessionId(data.sessionId);
            setMessages([]);
            setChatStatus("New chat started. Send a message!");
            toast.success("New chat started!");
        } catch (error) {
            toast.error("Failed to start new chat.");
            console.error("App.jsx: Failed to start new chat:", error);
        }
    };

    const handleSelectSessionFromHistory = (sessionId) => {
        console.log("App.jsx: handleSelectSessionFromHistory called with sessionId:", sessionId);
        if (sessionId && sessionId !== currentSessionId) {
            setGlobalSessionId(sessionId); 
            toast.success(`Loading session...`);
        } else if (sessionId === currentSessionId) {
            toast.info("This session is already loaded.");
        }
        setIsHistoryModalOpen(false); 
    };

    if (appInitializing) { 
        console.log("App.jsx: Rendering Initializing AI Tutor... screen.");
        return (
            <div className="fixed inset-0 flex flex-col items-center justify-center bg-background-light dark:bg-background-dark text-text-light dark:text-text-dark">
                <div className="animate-spin rounded-full h-12 w-12 border-t-4 border-b-4 border-primary mb-4"></div>
                <p className="text-xl">Initializing AI Tutor...</p>
            </div>
        );
    }

    console.log("App.jsx: Proceeding to render AuthModal or Main App. showAuthModal:", showAuthModal, "Token:", token, "User:", user);
    return (
        <div className={`flex flex-col h-screen overflow-hidden font-sans ${theme}`}>
            <AnimatePresence>
                {showAuthModal && !token && (
                    <AuthModal isOpen={showAuthModal} onClose={handleAuthSuccess} />
                )}
            </AnimatePresence>

            {(token && user) && (
                <>
                    <TopNav
                        user={user}
                        onLogout={handleLogoutAndShowModal}
                        onNewChat={handleNewChat}
                        onHistoryClick={() => { console.log("App.jsx: History button clicked."); setIsHistoryModalOpen(true); }}
                        orchestratorStatus={orchestratorStatus}
                    />
                    <div className="flex flex-1 overflow-hidden pt-16 bg-background-light dark:bg-background-dark">
                        <AnimatePresence mode="wait">
                            {isLeftPanelOpen ? (
                                <motion.aside 
                                    key="left-panel-main"
                                    initial={{ x: '-100%', opacity: 0.5 }}
                                    animate={{ x: '0%', opacity: 1 }}
                                    exit={{ x: '-100%', opacity: 0.5 }}
                                    transition={{ type: 'spring', stiffness: 300, damping: 30 }}
                                    className="w-full md:w-72 lg:w-80 xl:w-96 bg-surface-light dark:bg-surface-dark border-r border-border-light dark:border-border-dark overflow-y-auto p-3 sm:p-4 shadow-lg flex-shrink-0 custom-scrollbar"
                                >
                                    <LeftPanel /> 
                                </motion.aside>
                            ) : (
                                // If you want collapsed navs, ensure they are imported and files exist
                                // <LeftCollapsedNav /> 
                                null // Or render nothing if panel is closed and no collapsed nav
                            )}
                        </AnimatePresence>
                        
                        <main className={`flex-1 flex flex-col overflow-hidden p-1 sm:p-2 md:p-4 
                                         transition-all duration-300 ease-in-out
                                         ${isLeftPanelOpen ? 'lg:ml-0' : 'lg:ml-0'}  {/* Adjust if using collapsed nav width */}
                                         ${isRightPanelOpen ? 'lg:mr-0' : 'lg:mr-0'} {/* Adjust if using collapsed nav width */} `}>
                           <CenterPanel 
                                messages={messages} 
                                setMessages={setMessages} 
                                currentSessionId={currentSessionId}
                                chatStatus={chatStatus}
                                setChatStatus={setChatStatus}
                            />
                        </main>

                        <AnimatePresence mode="wait">
                            {isRightPanelOpen ? (
                                <motion.aside 
                                    key="right-panel-main"
                                    initial={{ x: '100%', opacity: 0.5 }}
                                    animate={{ x: '0%', opacity: 1 }}
                                    exit={{ x: '100%', opacity: 0.5 }}
                                    transition={{ type: 'spring', stiffness: 300, damping: 30 }}
                                    className="hidden md:flex md:flex-col md:w-72 lg:w-80 xl:w-96 bg-surface-light dark:bg-surface-dark border-l border-border-light dark:border-border-dark overflow-y-auto p-3 sm:p-4 shadow-lg flex-shrink-0 custom-scrollbar"
                                >
                                    <RightPanel />
                                </motion.aside>
                            ) : (
                                // <RightCollapsedNav />
                                null // Or render nothing
                            )}
                        </AnimatePresence>
                    </div>
                    
                    <ChatHistoryModal
                        isOpen={isHistoryModalOpen}
                        onClose={() => setIsHistoryModalOpen(false)}
                        onSelectSession={handleSelectSessionFromHistory}
                    />
                </>
            )}
            
            { !appInitializing && !token && !showAuthModal && (
                 <div className="fixed inset-0 flex flex-col items-center justify-center bg-background-light dark:bg-background-dark text-text-light dark:text-text-dark">
                     <p className="text-xl">Please <button 
                        onClick={()=> { setShowAuthModal(true); }} 
                        className="text-primary hover:underline font-semibold"
                        >log in</button> to continue.</p>
                 </div>
            )}
        </div>
    );
}

export default App;
```

`src/components/analysis/AnalysisTool.jsx`

```javascript
import React, { useState } from 'react';
import api from '../../services/api';
import toast from 'react-hot-toast';
import MindmapViewer from './MindmapViewer'; // Import if needed
import { ChevronDown, ChevronUp, Loader2, AlertTriangle } from 'lucide-react';
import * as LucideIcons from 'lucide-react'; // Import all for dynamic icon
import { marked } from 'marked';


const createMarkup = (markdownText) => {
    if (!markdownText) return { __html: '' };
    return { __html: marked.parse(markdownText) };
};


function AnalysisTool({ toolType, title, icon, selectedDocumentFilename }) { // selectedDocumentFilename passed from parent
    const [isOpen, setIsOpen] = useState(false);
    const [result, setResult] = useState(null);
    const [thinking, setThinking] = useState(null);
    const [isLoading, setIsLoading] = useState(false);
    const [error, setError] = useState('');

    const IconComponent = LucideIcons[icon] || LucideIcons.HelpCircle; // Default icon

    const handleRunAnalysis = async () => {
        if (!selectedDocumentFilename) {
            toast.error("Please select a document from the left panel first.");
            return;
        }
        setIsLoading(true);
        setError('');
        setResult(null);
        setThinking(null);
        const toastId = toast.loading(`Generating ${title} for ${selectedDocumentFilename}...`);

        try {
            const payload = { filename: selectedDocumentFilename, analysis_type: toolType };
            const response = await api.requestAnalysis(payload);
            setResult(response.content);
            setThinking(response.thinking);
            setIsOpen(true); // Auto-open on successful analysis
            toast.success(`${title} generated!`, { id: toastId });
        } catch (err) {
            const errorMessage = err.response?.data?.message || err.message || `Failed to generate ${title}.`;
            setError(errorMessage);
            toast.error(errorMessage, { id: toastId });
            console.error(err);
        } finally {
            setIsLoading(false);
        }
    };

    return (
        <div className="bg-surface-light dark:bg-gray-800 p-3 rounded-lg border border-gray-200 dark:border-gray-700 shadow-sm">
            <div className="flex items-center justify-between">
                <button 
                    onClick={() => setIsOpen(!isOpen)}
                    className="flex items-center gap-2 text-sm font-medium text-text-light dark:text-text-dark focus:outline-none w-full text-left"
                >
                    <IconComponent size={16} className="text-primary" />
                    <span>{title}</span>
                </button>
                <div className="flex items-center gap-2">
                    <button
                        onClick={handleRunAnalysis}
                        className="px-2 py-1 text-xs btn-primary-custom disabled:opacity-50"
                        disabled={isLoading || !selectedDocumentFilename}
                        title={!selectedDocumentFilename ? "Select a document first" : `Run ${title}`}
                    >
                        {isLoading ? <Loader2 size={14} className="animate-spin" /> : "Run"}
                    </button>
                    <button onClick={() => setIsOpen(!isOpen)} className="p-1 text-text-muted-light dark:text-text-muted-dark hover:text-primary">
                        {isOpen ? <ChevronUp size={16} /> : <ChevronDown size={16} />}
                    </button>
                </div>
            </div>

            {isOpen && (
                <div className="mt-2 pt-2 border-t border-gray-200 dark:border-gray-600 animate-fadeIn">
                    {isLoading && <p className="text-xs text-text-muted-light dark:text-text-muted-dark p-2">Generating...</p>}
                    {error && (
                        <div className="p-2 bg-red-100 dark:bg-red-900 border border-red-400 dark:border-red-700 text-red-700 dark:text-red-200 rounded-md text-xs flex items-center gap-1">
                            <AlertTriangle size={14} /> {error}
                        </div>
                    )}
                    {thinking && !error && (
                        <details className="text-xs mb-1.5">
                            <summary className="cursor-pointer text-text-muted-light dark:text-text-muted-dark hover:text-primary">AI Reasoning</summary>
                            <pre className="mt-1 p-1.5 bg-gray-100 dark:bg-gray-700 rounded text-text-light dark:text-text-dark text-[0.7rem] max-h-24 overflow-y-auto custom-scrollbar">
                                <code>{thinking}</code>
                            </pre>
                        </details>
                    )}
                    {result && !error && (
                        toolType === 'mindmap' ? (
                            <MindmapViewer markdownContent={result} />
                        ) : (
                            <div className="prose prose-xs dark:prose-invert max-w-none text-text-light dark:text-text-dark p-1 max-h-60 overflow-y-auto custom-scrollbar text-[0.75rem]"
                                 dangerouslySetInnerHTML={createMarkup(result)}
                            />
                        )
                    )}
                    {!isLoading && !result && !error && <p className="text-xs text-text-muted-light dark:text-text-muted-dark p-2">Click "Run" to generate analysis.</p>}
                </div>
            )}
        </div>
    );
}
export default AnalysisTool;
```

`src/components/analysis/MindmapViewer.jsx`

```javascript
import React, { useEffect, useRef, useState } from 'react';
import toast from 'react-hot-toast';

// Ensure Markmap libraries are loaded globally from index.html (d3, markmap-lib, markmap-view, markmap-toolbar)

function MindmapViewer({ markdownContent }) {
    const svgRef = useRef(null);
    const [markmapInstance, setMarkmapInstance] = useState(null);
    const [toolbarInstance, setToolbarInstance] = useState(null);
    const { Transformer, Markmap, Toolbar } = window.markmap; // Access global markmap

    useEffect(() => {
        if (!markdownContent || !svgRef.current || !Transformer || !Markmap || !Toolbar) {
            if (svgRef.current) svgRef.current.innerHTML = ''; // Clear previous
            return;
        }
        
        let mm, tb;
        try {
            // Cleanup previous instances if they exist
            if (markmapInstance && typeof markmapInstance.destroy === 'function') {
                markmapInstance.destroy();
            }
            if (toolbarInstance && toolbarInstance.el && toolbarInstance.el.parentNode) {
                toolbarInstance.el.parentNode.removeChild(toolbarInstance.el);
            }

            const transformer = new Transformer();
            const { root, features } = transformer.transform(markdownContent);
            
            svgRef.current.innerHTML = ''; // Clear before re-rendering
            mm = Markmap.create(svgRef.current, null, root); // Create new Markmap
            setMarkmapInstance(mm);

            // Create and prepend toolbar
            tb = Toolbar.create(mm);
            svgRef.current.parentNode.insertBefore(tb.el, svgRef.current);
            setToolbarInstance(tb);
            
            // Auto-fit after a short delay to ensure rendering is complete
            setTimeout(() => mm.fit(), 100);

        } catch (e) {
            console.error("Error rendering Markmap:", e);
            toast.error("Failed to render mind map. Check console for details.");
            if (svgRef.current) svgRef.current.innerHTML = '<p class="text-xs text-red-500 p-2">Error rendering mind map. Invalid Markdown for mind map?</p>';
        }
        
        // Cleanup function for when component unmounts or markdownContent changes
        return () => {
            if (mm && typeof mm.destroy === 'function') {
                mm.destroy();
            }
            if (tb && tb.el && tb.el.parentNode) {
                tb.el.parentNode.removeChild(tb.el);
            }
        };
    // eslint-disable-next-line react-hooks/exhaustive-deps 
    }, [markdownContent]); // Rerun when markdownContent changes

    if (!markdownContent) {
        return <p className="text-xs text-text-muted-light dark:text-text-muted-dark p-2">No mind map data to display.</p>;
    }

    return (
        <div className="relative w-full h-80 md:h-96 my-2">
            {/* Toolbar will be prepended here by useEffect */}
            <svg ref={svgRef} className="w-full h-full border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-gray-800 shadow-inner"></svg>
        </div>
    );
}

export default MindmapViewer;
```

`src/components/auth/AuthModal.jsx`

```javascript
// import React, { useState } from 'react';
// import { useAuth } from '../../hooks/useAuth';
// import { useAppState } from '../../contexts/AppStateContext';
// import LLMSelection from './LLMSelection';
// import api from '../../services/api';
// import toast from 'react-hot-toast';
// import { LogIn, UserPlus, X } from 'lucide-react';

// function AuthModal({ isOpen, onClose }) {
//     const { login, signup } = useAuth();
//     const { selectedLLM, switchLLM: setGlobalLLM } = useAppState(); // Using context for global LLM
    
//     const [isLoginView, setIsLoginView] = useState(true);
//     const [username, setUsername] = useState('');
//     const [password, setPassword] = useState('');
//     const [localSelectedLLM, setLocalSelectedLLM] = useState(selectedLLM || 'ollama');
//     const [geminiApiKey, setGeminiApiKey] = useState(''); // For initial setup
    
//     const [error, setError] = useState('');
//     const [loading, setLoading] = useState(false);

//     const handleLlmChange = (llm) => {
//         setLocalSelectedLLM(llm);
//     };

//     const handleSubmit = async (e) => {
//         e.preventDefault();
//         setError('');
//         setLoading(true);
//         toast.loading(isLoginView ? 'Logging in...' : 'Signing up...');

//         try {
//             let response;
//             if (isLoginView) {
//                 response = await login({ username, password });
//                 // After login, fetch user's preferred LLM from backend or use local default
//                 // For now, we assume login doesn't change the global LLM state directly here.
//                 // The TopNav LLM switcher will handle explicit changes.
//             } else { // Signup
//                 // For signup, we include LLM preference and potentially API key
//                 const signupData = {
//                     username,
//                     password,
//                     // Include LLM preference if your backend stores it on signup
//                     // llmProvider: localSelectedLLM, 
//                 };
//                 // The API key for Gemini should ideally be set via a separate user config endpoint AFTER login for security.
//                 // Only if backend handles it very securely on signup path.
//                 response = await signup(signupData);
//                 setGlobalLLM(localSelectedLLM); // Set global LLM on successful signup

//                 // If Gemini was selected and API key provided, try to update user config
//                 if (localSelectedLLM === 'gemini' && geminiApiKey.trim()) {
//                     // This assumes successful signup returns a token that's now set in api.js interceptor
//                     // You might need to wait for the token to be fully set in AuthContext
//                     try {
//                         await api.updateUserLLMConfig({ llmProvider: 'gemini', apiKey: geminiApiKey.trim() });
//                         toast.success('Gemini API key configured (if provided and valid).');
//                     } catch (configError) {
//                         toast.error(`Signed up, but failed to configure Gemini API key: ${configError.message}`);
//                     }
//                 }
//             }
//             toast.dismiss();
//             toast.success(isLoginView ? 'Logged in successfully!' : 'Signed up successfully!');
//             onClose(response); // Close modal and signal App.js to update state
//         } catch (err) {
//             toast.dismiss();
//             const errorMessage = err.response?.data?.message || err.message || `Failed to ${isLoginView ? 'login' : 'sign up'}`;
//             setError(errorMessage);
//             toast.error(errorMessage);
//         } finally {
//             setLoading(false);
//         }
//     };

//     if (!isOpen) return null;

//     return (
//         <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 p-4 animate-fadeIn">
//             <div className="bg-surface-light dark:bg-surface-dark p-6 sm:p-8 rounded-xl shadow-2xl w-full max-w-md transform transition-all">
//                 <div className="flex justify-between items-center mb-6">
//                     <h2 className="text-2xl font-bold text-text-light dark:text-text-dark">
//                         {isLoginView ? 'Welcome Back!' : 'Join Us'}
//                     </h2>
//                     <button onClick={onClose} className="text-text-muted-light dark:text-text-muted-dark hover:text-red-500 transition-colors">
//                         <X size={24} />
//                     </button>
//                 </div>

//                 {error && <div className="mb-4 p-3 bg-red-100 dark:bg-red-900 border border-red-400 dark:border-red-700 text-red-700 dark:text-red-200 rounded-md text-sm">{error}</div>}

//                 <form onSubmit={handleSubmit} className="space-y-6">
//                     <div>
//                         <label htmlFor="username" className="block text-sm font-medium text-text-light dark:text-text-dark mb-1">Username</label>
//                         <input
//                             type="text"
//                             id="username"
//                             className="input-custom"
//                             value={username}
//                             onChange={(e) => setUsername(e.target.value)}
//                             required
//                             disabled={loading}
//                         />
//                     </div>
//                     <div>
//                         <label htmlFor="password" className="block text-sm font-medium text-text-light dark:text-text-dark mb-1">Password</label>
//                         <input
//                             type="password"
//                             id="password"
//                             className="input-custom"
//                             value={password}
//                             onChange={(e) => setPassword(e.target.value)}
//                             required
//                             minLength="6"
//                             disabled={loading}
//                         />
//                     </div>

//                     {!isLoginView && (
//                         <>
//                             <LLMSelection selectedLLM={localSelectedLLM} onLlmChange={handleLlmChange} />
//                             {localSelectedLLM === 'gemini' && (
//                                 <div>
//                                     <label htmlFor="geminiApiKey" className="block text-sm font-medium text-text-light dark:text-text-dark mb-1">
//                                         Gemini API Key (Optional - for cloud features)
//                                     </label>
//                                     <input
//                                         type="password" // Keep it as password type for some obfuscation
//                                         id="geminiApiKey"
//                                         className="input-custom"
//                                         placeholder="Enter your Gemini API Key"
//                                         value={geminiApiKey}
//                                         onChange={(e) => setGeminiApiKey(e.target.value)}
//                                         disabled={loading}
//                                     />
//                                     <p className="text-xs text-text-muted-light dark:text-text-muted-dark mt-1">
//                                         Your API key will be stored securely by the backend.
//                                     </p>
//                                 </div>
//                             )}
//                         </>
//                     )}

//                     <button
//                         type="submit"
//                         className="w-full btn-primary-custom flex items-center justify-center gap-2"
//                         disabled={loading}
//                     >
//                         {loading ? (
//                             <span className="animate-spin rounded-full h-5 w-5 border-t-2 border-b-2 border-white"></span>
//                         ) : (
//                             isLoginView ? <LogIn size={20}/> : <UserPlus size={20}/>
//                         )}
//                         {isLoginView ? 'Login' : 'Sign Up'}
//                     </button>
//                 </form>

//                 <p className="mt-6 text-center text-sm">
//                     <button
//                         onClick={() => { setIsLoginView(!isLoginView); setError(''); }}
//                         className="font-medium text-primary hover:text-primary-dark dark:text-primary-light dark:hover:text-primary transition-colors"
//                         disabled={loading}
//                     >
//                         {isLoginView ? "Don't have an account? Sign Up" : "Already have an account? Login"}
//                     </button>
//                 </p>
//             </div>
//         </div>
//     );
// }
// export default AuthModal;
import React, { useState } from 'react';
import { useAuth } from '../../hooks/useAuth';
import { useAppState } from '../../contexts/AppStateContext';
import LLMSelection from './LLMSelection';
import api from '../../services/api'; // For real signup/login
import toast from 'react-hot-toast';
import { LogIn, UserPlus, X, Terminal } from 'lucide-react'; // Added Terminal for dev

function AuthModal({ isOpen, onClose }) {
    const { login, signup, devLogin, DEV_MODE_ALLOW_DEV_LOGIN } = useAuth(); // Get devLogin and flag
    const { selectedLLM, switchLLM: setGlobalLLM } = useAppState();
    
    const [isLoginView, setIsLoginView] = useState(true);
    const [username, setUsername] = useState(DEV_MODE_ALLOW_DEV_LOGIN ? 'DevUser' : ''); // Pre-fill for dev
    const [password, setPassword] = useState(DEV_MODE_ALLOW_DEV_LOGIN ? 'devpass' : ''); // Pre-fill for dev
    const [localSelectedLLM, setLocalSelectedLLM] = useState(selectedLLM || 'ollama');
    const [geminiApiKey, setGeminiApiKey] = useState('');
    
    const [error, setError] = useState('');
    const [loading, setLoading] = useState(false);

    const handleLlmChange = (llm) => setLocalSelectedLLM(llm);

    const handleSubmit = async (e) => {
        e.preventDefault();
        setError('');
        setLoading(true);
        const loadingToastId = toast.loading(isLoginView ? 'Logging in...' : 'Signing up...');

        try {
            let response;
            if (isLoginView) {
                response = await login({ username, password });
            } else {
                const signupData = { username, password /*, llmProvider: localSelectedLLM (if backend handles) */ };
                response = await signup(signupData);
                setGlobalLLM(localSelectedLLM);
                if (localSelectedLLM === 'gemini' && geminiApiKey.trim()) {
                    try {
                        await api.updateUserLLMConfig({ llmProvider: 'gemini', apiKey: geminiApiKey.trim() });
                        toast.success('Gemini API key configured.');
                    } catch (configError) {
                        toast.error(`Signed up, but failed to config Gemini key: ${configError.message}`);
                    }
                }
            }
            toast.dismiss(loadingToastId);
            toast.success(isLoginView ? 'Logged in successfully!' : 'Signed up successfully!');
            onClose(response); 
        } catch (err) {
            toast.dismiss(loadingToastId);
            const errorMessage = err.response?.data?.message || err.message || `Failed: ${isLoginView ? 'login' : 'signup'}`;
            setError(errorMessage);
            toast.error(errorMessage);
        } finally {
            setLoading(false);
        }
    };

    const handleDevLogin = () => {
        if (devLogin) {
            const devData = devLogin(); // This sets token/user in AuthContext
            if (devData) {
                toast.success("Logged in as Dev User!");
                onClose(devData); // Pass devData which includes a mock sessionId
            }
        }
    };

    if (!isOpen) return null;

    return (
        <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 p-4 animate-fadeIn">
            <div className="bg-surface-light dark:bg-surface-dark p-6 sm:p-8 rounded-xl shadow-2xl w-full max-w-md">
                {/* ... (Modal Header as before) ... */}
                <div className="flex justify-between items-center mb-6">
                    <h2 className="text-2xl font-bold text-text-light dark:text-text-dark">
                        {isLoginView ? 'Welcome Back!' : 'Join Us'}
                    </h2>
                    <button onClick={() => onClose(null)} className="text-text-muted-light dark:text-text-muted-dark hover:text-red-500">
                        <X size={24} />
                    </button>
                </div>

                {error && <div className="mb-4 p-3 bg-red-100 dark:bg-red-900 border border-red-400 dark:border-red-700 text-red-700 dark:text-red-200 rounded-md text-sm">{error}</div>}

                <form onSubmit={handleSubmit} className="space-y-6">
                    {/* ... (Username and Password inputs as before, possibly pre-filled if DEV_MODE_ALLOW_DEV_LOGIN) ... */}
                    <div>
                        <label /* ... */ >Username</label>
                        <input value={username} onChange={(e) => setUsername(e.target.value)} /* ... */ />
                    </div>
                    <div>
                        <label /* ... */ >Password</label>
                        <input type="password" value={password} onChange={(e) => setPassword(e.target.value)} /* ... */ />
                    </div>

                    {!isLoginView && ( /* LLM Selection and Gemini Key for Signup View */
                        <>
                            <LLMSelection selectedLLM={localSelectedLLM} onLlmChange={handleLlmChange} />
                            {/* ... (Gemini API Key input as before) ... */}
                        </>
                    )}

                    <button type="submit" /* ... */ >
                        {/* ... (Loading spinner or Icon + Text) ... */}
                        {isLoginView ? 'Login' : 'Sign Up'}
                    </button>
                </form>

                <p className="mt-6 text-center text-sm">
                    <button onClick={() => setIsLoginView(!isLoginView)} /* ... */ >
                        {isLoginView ? "Don't have an account? Sign Up" : "Already have an account? Login"}
                    </button>
                </p>

                {/* Dev Login Button */}
                {DEV_MODE_ALLOW_DEV_LOGIN && (
                    <div className="mt-4 pt-4 border-t border-gray-200 dark:border-gray-700">
                        <button
                            type="button"
                            onClick={handleDevLogin}
                            className="w-full flex items-center justify-center gap-2 px-4 py-2 text-sm font-medium rounded-md text-yellow-700 dark:text-yellow-300 bg-yellow-100 dark:bg-yellow-700 hover:bg-yellow-200 dark:hover:bg-yellow-600 transition-colors focus:outline-none focus:ring-2 focus:ring-yellow-500"
                        >
                            <Terminal size={18} /> Dev Quick Login
                        </button>
                    </div>
                )}
            </div>
        </div>
    );
}
export default AuthModal;
```

`src/components/auth/LLMSelection.jsx`

```javascript
import React from 'react';
import { HardDrive, Cloud } from 'lucide-react'; // Example icons

function LLMSelection({ selectedLLM, onLlmChange }) {
    const llms = [
        { id: 'ollama', name: 'Ollama LLM', description: 'Local & Default', Icon: HardDrive },
        { id: 'gemini', name: 'Gemini LLM', description: 'Cloud Powered', Icon: Cloud },
    ];

    return (
        <div>
            <label className="block text-sm font-medium text-text-light dark:text-text-dark mb-2">
                Choose Your Preferred LLM
            </label>
            <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
                {llms.map((llm) => (
                    <button
                        key={llm.id}
                        type="button"
                        onClick={() => onLlmChange(llm.id)}
                        className={`p-4 border rounded-lg text-left transition-all duration-150 focus:outline-none
                            ${selectedLLM === llm.id 
                                ? 'bg-primary-light dark:bg-primary-dark border-primary dark:border-primary-light ring-2 ring-primary dark:ring-primary-light shadow-lg' 
                                : 'bg-surface-light dark:bg-surface-dark border-gray-300 dark:border-gray-600 hover:border-primary-light dark:hover:border-primary-dark hover:shadow-md'
                            }`}
                    >
                        <div className="flex items-center mb-1">
                            <llm.Icon size={20} className={`mr-2 ${selectedLLM === llm.id ? 'text-primary dark:text-primary-light' : 'text-text-muted-light dark:text-text-muted-dark'}`} />
                            <span className={`font-semibold ${selectedLLM === llm.id ? 'text-primary dark:text-primary-light' : 'text-text-light dark:text-text-dark'}`}>
                                {llm.name}
                            </span>
                        </div>
                        <p className={`text-xs ${selectedLLM === llm.id ? 'text-primary-dark dark:text-primary' : 'text-text-muted-light dark:text-text-muted-dark'}`}>
                            {llm.description}
                        </p>
                    </button>
                ))}
            </div>
        </div>
    );
}

export default LLMSelection;
```

`src/components/chat/ChatHistory.jsx`

```javascript
import React, { useRef, useEffect } from 'react';
import MessageBubble from './MessageBubble';
import { motion, AnimatePresence } from 'framer-motion';

function ChatHistory({ messages, isLoading }) {
    const chatHistoryRef = useRef(null);

    useEffect(() => {
        if (chatHistoryRef.current) {
            chatHistoryRef.current.scrollTop = chatHistoryRef.current.scrollHeight;
        }
    }, [messages]);

    return (
        <div ref={chatHistoryRef} className="flex-1 overflow-y-auto p-4 space-y-4">
            <AnimatePresence initial={false}>
                {messages.map((msg, index) => (
                    <motion.div
                        key={msg.id || index} // Critical for AnimatePresence
                        layout
                        initial={{ opacity: 0, y: 20 }}
                        animate={{ opacity: 1, y: 0 }}
                        exit={{ opacity: 0, y: -10 }}
                        transition={{ duration: 0.3, ease: "easeOut" }}
                    >
                        <MessageBubble
                            sender={msg.sender}
                            text={msg.text}
                            thinking={msg.thinking}
                            references={msg.references}
                            timestamp={msg.timestamp}
                            sourcePipeline={msg.source_pipeline}
                        />
                    </motion.div>
                ))}
            </AnimatePresence>
            {isLoading && messages.length > 0 && ( // Show typing indicator only if there are prior messages
                 <motion.div 
                    layout
                    initial={{ opacity: 0, y: 10 }}
                    animate={{ opacity: 1, y: 0 }}
                    className="flex justify-start pl-2 mt-2"
                 >
                    <div className="message-bubble bot-message bg-surface-light dark:bg-surface-dark p-2 inline-flex items-center gap-1">
                        <span className="animate-pulse text-text-muted-light dark:text-text-muted-dark text-xs">●</span>
                        <span className="animate-pulse delay-100 text-text-muted-light dark:text-text-muted-dark text-xs">●</span>
                        <span className="animate-pulse delay-200 text-text-muted-light dark:text-text-muted-dark text-xs">●</span>
                    </div>
                </motion.div>
            )}
        </div>
    );
}
export default ChatHistory;

```

`src/components/chat/ChatHistoryModal.jsx`

```javascript
import React, { useState, useEffect, useCallback } from 'react';
import api from '../../services/api';
import toast from 'react-hot-toast';
import { X, MessageSquareText, Loader2, AlertTriangle } from 'lucide-react';
import Modal from '../core/Modal.jsx'; // Assuming your generic Modal component

const formatDate = (dateString) => {
    if (!dateString) return 'N/A';
    try {
        return new Date(dateString).toLocaleString(undefined, { 
            month: 'short', day: 'numeric', year: 'numeric', hour: '2-digit', minute: '2-digit' 
        });
    } catch (e) {
        return 'Invalid Date';
    }
};

function ChatHistoryModal({ isOpen, onClose, onSelectSession }) {
    const [sessions, setSessions] = useState([]);
    const [selectedSessionId, setSelectedSessionId] = useState(null);
    const [sessionMessages, setSessionMessages] = useState([]);
    const [loadingSessions, setLoadingSessions] = useState(false);
    const [loadingMessages, setLoadingMessages] = useState(false);
    const [error, setError] = useState('');

    const fetchSessions = useCallback(async () => {
        if (!isOpen) return; 
        setLoadingSessions(true);
        setError('');
        try {
            const data = await api.getChatSessions(); 
            setSessions(Array.isArray(data) ? data : []);
        } catch (err) {
            toast.error("Failed to load chat sessions.");
            setError(err.message || "Could not fetch sessions.");
        } finally {
            setLoadingSessions(false);
        }
    }, [isOpen]);

    useEffect(() => {
        if (isOpen) { // Only fetch when modal becomes open
            fetchSessions();
            setSelectedSessionId(null); // Reset selection when modal reopens
            setSessionMessages([]);
        }
    }, [isOpen, fetchSessions]); 

    const handleSessionSelect = async (sessionId) => {
        if (selectedSessionId === sessionId) return; // Avoid re-fetching if already selected

        setSelectedSessionId(sessionId);
        setLoadingMessages(true);
        setSessionMessages([]);
        setError(''); 
        try {
            const historyData = await api.getChatHistory(sessionId);
            setSessionMessages((Array.isArray(historyData) ? historyData : []).map(msg => ({
                id: msg.id || msg._id || String(Math.random() + Date.now()),
                sender: msg.role === 'model' ? 'bot' : 'user',
                text: msg.parts && msg.parts.length > 0 ? msg.parts[0].text : (msg.text || ''),
                timestamp: msg.timestamp
            })));
        } catch (err) {
            toast.error("Failed to load messages for this session.");
            setError(`Error loading messages: ${err.message}`);
        } finally {
            setLoadingMessages(false);
        }
    };

    const handleLoadSessionAndClose = () => {
        if (selectedSessionId) {
            onSelectSession(selectedSessionId); 
            onClose();
        } else {
            toast.error("Please select a session to load.");
        }
    };
    
    // Placeholder for delete functionality
    // const handleDeleteSession = async (sessionIdToDelete, e) => { ... };

    return (
        <Modal isOpen={isOpen} onClose={onClose} title="Chat History" size="2xl">
            <div className="flex flex-col md:flex-row gap-4 max-h-[70vh] h-[70vh]">
                {/* Sessions List */}
                <div className="w-full md:w-1/3 border-r border-border-light dark:border-border-dark pr-0 md:pr-2 overflow-y-auto custom-scrollbar">
                    <h3 className="text-sm font-semibold mb-2 text-text-light dark:text-text-dark px-1">Sessions</h3>
                    {loadingSessions && <div className="flex justify-center p-4"><Loader2 className="animate-spin text-primary" size={24}/></div>}
                    {!loadingSessions && error && !sessions.length && <div className="text-red-500 text-xs p-2">{error}</div>}
                    {!loadingSessions && !error && sessions.length === 0 && <p className="text-xs text-text-muted-light dark:text-text-muted-dark p-2">No past sessions found.</p>}
                    
                    <ul className="space-y-1">
                        {sessions.map(session => (
                            <li key={session.sessionId}
                                onClick={() => handleSessionSelect(session.sessionId)}
                                className={`p-2.5 rounded-md cursor-pointer text-xs transition-colors group relative
                                            ${selectedSessionId === session.sessionId 
                                                ? 'bg-primary text-white dark:bg-primary-dark' 
                                                : 'bg-surface-light dark:bg-gray-800 hover:bg-gray-100 dark:hover:bg-gray-700'}`}
                            >
                                <div className="font-medium truncate" title={session.preview}>{session.preview || `Session ${session.sessionId.substring(0,8)}`}</div>
                                <div className={`text-[0.7rem] ${selectedSessionId === session.sessionId ? 'text-blue-100 dark:text-blue-200' : 'text-text-muted-light dark:text-text-muted-dark'}`}>
                                    {formatDate(session.updatedAt)} - {session.messageCount} msgs
                                </div>
                                {/* Delete button placeholder
                                <button 
                                    className="absolute top-1 right-1 p-1 text-red-400 hover:text-red-600 opacity-0 group-hover:opacity-100 transition-opacity"
                                    onClick={(e) => handleDeleteSession(session.sessionId, e)}
                                    title="Delete session"
                                >
                                    <Trash2 size={14} />
                                </button>
                                */}
                            </li>
                        ))}
                    </ul>
                </div>

                {/* Session Details */}
                <div className="w-full md:w-2/3 flex flex-col overflow-hidden mt-4 md:mt-0">
                    <h3 className="text-sm font-semibold mb-2 text-text-light dark:text-text-dark">Session Details</h3>
                    <div className="flex-grow bg-gray-50 dark:bg-gray-800 p-3 rounded-md overflow-y-auto custom-scrollbar border border-border-light dark:border-border-dark">
                        {loadingMessages && <div className="flex justify-center p-4"><Loader2 className="animate-spin text-primary" size={24} /></div>}
                        {!selectedSessionId && !loadingMessages && (
                            <div className="flex flex-col items-center justify-center h-full text-text-muted-light dark:text-text-muted-dark text-sm">
                                <MessageSquareText size={40} className="mb-3 opacity-50" />
                                <p>Select a session from the left to view its messages.</p>
                            </div>
                        )}
                        {selectedSessionId && !loadingMessages && sessionMessages.length === 0 && 
                            <p className="text-center text-sm text-text-muted-light dark:text-text-muted-dark p-4">No messages in this session.</p>
                        }
                        <div className="space-y-3">
                            {sessionMessages.map(msg => (
                                <div key={msg.id} 
                                     className={`p-2.5 rounded-lg shadow-sm w-fit max-w-[90%] text-xs
                                                ${msg.sender === 'user' 
                                                    ? 'bg-blue-500 text-white ml-auto' 
                                                    : 'bg-gray-200 text-gray-800 dark:bg-gray-700 dark:text-gray-100'}`}>
                                    <p className="font-semibold text-[0.7rem] mb-0.5">{msg.sender === 'user' ? 'You' : 'AI Tutor'}</p>
                                    <p className="whitespace-pre-wrap break-words">{msg.text}</p>
                                    <p className="text-[0.65rem] opacity-70 mt-1 text-right">{formatDate(msg.timestamp)}</p>
                                </div>
                            ))}
                        </div>
                    </div>
                </div>
            </div>
            <div className="mt-6 pt-4 border-t border-border-light dark:border-border-dark flex justify-end gap-3">
                <button 
                    onClick={onClose} 
                    className="px-4 py-2 text-xs font-medium rounded-md bg-gray-200 dark:bg-gray-600 hover:bg-gray-300 dark:hover:bg-gray-500 text-text-light dark:text-text-dark transition-colors"
                >
                    Close
                </button>
                <button 
                    onClick={handleLoadSessionAndClose} 
                    className="px-4 py-2 text-xs font-medium rounded-md btn-primary disabled:opacity-50"
                    disabled={!selectedSessionId || loadingMessages || loadingSessions}
                >
                    Load Selected Session
                </button>
            </div>
        </Modal>
    );
}
export default ChatHistoryModal;
```

`src/components/chat/ChatInput.jsx`

```javascript
import React, { useState, useEffect, useRef } from 'react';
import { Send, Mic, PlusCircle, Loader2, SearchCheck, SearchSlash } from 'lucide-react'; // SearchCheck for RAG on, SearchSlash for RAG off
import { useWebSpeech } from '../../hooks/useWebSpeech'; // You'll need to create this hook

function ChatInput({ onSendMessage, isLoading, currentStatus, useRag, setUseRag }) {
    const [inputValue, setInputValue] = useState('');
    const { transcript, listening, isSpeechSupported, startListening, stopListening, resetTranscript } = useWebSpeech();
    const textareaRef = useRef(null);

    useEffect(() => {
        if (transcript) {
            setInputValue(prev => prev + (prev ? " " : "") + transcript);
            resetTranscript(); // Clear transcript after appending
        }
    }, [transcript, resetTranscript]);
    
    // Auto-resize textarea
    useEffect(() => {
        if (textareaRef.current) {
            textareaRef.current.style.height = 'auto'; // Reset height
            textareaRef.current.style.height = `${textareaRef.current.scrollHeight}px`; // Set to scroll height
        }
    }, [inputValue]);


    const handleSubmit = (e) => {
        e.preventDefault();
        if (inputValue.trim() && !isLoading) {
            onSendMessage(inputValue);
            setInputValue('');
        }
    };

    const toggleVoiceInput = () => {
        if (listening) {
            stopListening();
        } else {
            startListening();
        }
    };

    return (
        <div className="p-2 sm:p-4 border-t border-gray-200 dark:border-gray-700 bg-surface-light dark:bg-surface-dark">
            {/* Status Bar */}
            <div className="text-xs text-text-muted-light dark:text-text-muted-dark mb-1.5 h-4 transition-opacity duration-300">
                {isLoading ? (
                    <span className="flex items-center gap-1 animate-pulse">
                        <Loader2 size={12} className="animate-spin" /> {currentStatus || "Processing..."}
                    </span>
                ) : (
                    currentStatus || "Ready"
                )}
            </div>

            <form onSubmit={handleSubmit} className="flex items-end gap-2">
                {/* Attachment/Plus Button - Placeholder */}
                <button
                    type="button"
                    title="Attach file (Coming Soon)"
                    onClick={() => alert("Attachment feature coming soon!")}
                    className="p-2.5 rounded-lg text-text-muted-light dark:text-text-muted-dark hover:bg-gray-200 dark:hover:bg-gray-600 transition-colors focus:outline-none focus:ring-2 focus:ring-primary"
                >
                    <PlusCircle size={22} />
                </button>

                <textarea
                    ref={textareaRef}
                    value={inputValue}
                    onChange={(e) => setInputValue(e.target.value)}
                    onKeyDown={(e) => {
                        if (e.key === 'Enter' && !e.shiftKey && !isLoading) {
                            handleSubmit(e);
                        }
                    }}
                    placeholder="DeepResearch... Type your message or ask a question"
                    className="flex-1 p-2.5 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-800 text-text-light dark:text-text-dark focus:ring-2 focus:ring-primary focus:border-transparent outline-none resize-none min-h-[44px] max-h-32 custom-scrollbar text-sm"
                    rows="1"
                    disabled={isLoading}
                />

                {isSpeechSupported && (
                    <button
                        type="button"
                        onClick={toggleVoiceInput}
                        title={listening ? "Stop listening" : "Start voice input"}
                        className={`p-2.5 rounded-lg transition-colors focus:outline-none focus:ring-2 focus:ring-primary ${
                            listening 
                            ? 'bg-red-500 text-white animate-pulse' 
                            : 'text-text-muted-light dark:text-text-muted-dark hover:bg-gray-200 dark:hover:bg-gray-600'
                        }`}
                    >
                        <Mic size={20} />
                    </button>
                )}
                
                {/* RAG Toggle Button */}
                <button
                    type="button"
                    onClick={() => setUseRag(!useRag)}
                    title={useRag ? "Disable RAG (Chat with LLM directly)" : "Enable RAG (Use your documents)"}
                    className={`p-2.5 rounded-lg transition-colors focus:outline-none focus:ring-2 focus:ring-primary ${
                        useRag 
                        ? 'bg-green-500 text-white' 
                        : 'text-text-muted-light dark:text-text-muted-dark hover:bg-gray-200 dark:hover:bg-gray-600'
                    }`}
                    disabled={isLoading}
                >
                    {useRag ? <SearchCheck size={20} /> : <SearchSlash size={20} />}
                </button>

                <button
                    type="submit"
                    className="p-2.5 bg-primary text-white rounded-lg hover:bg-primary-dark transition-colors focus:outline-none focus:ring-2 focus:ring-primary focus:ring-opacity-75 disabled:opacity-50"
                    disabled={isLoading || !inputValue.trim()}
                >
                    <Send size={20} />
                </button>
            </form>
        </div>
    );
}
export default ChatInput;
```

`src/components/chat/MessageBubble.jsx`

```javascript
import React from 'react';
import { marked } from 'marked'; // Ensure marked is installed
import { ChevronDown, Brain, Link as LinkIcon, Zap, Server } from 'lucide-react'; // Zap for Ollama, Server for Gemini (example)

// Configure marked for consistent rendering
// WARNING: sanitize: false can be a security risk if LLM output is not trusted.
// For production, use DOMPurify:
// import DOMPurify from 'dompurify';
// const cleanHtml = DOMPurify.sanitize(rawHtml);
marked.setOptions({
  breaks: true,
  gfm: true,
  // sanitize: false, // Set to true or use DOMPurify for production if LLM output is untrusted
});

const createMarkup = (markdownText) => {
    if (!markdownText) return { __html: '' };
    const rawHtml = marked.parse(markdownText);
    // const cleanHtml = DOMPurify.sanitize(rawHtml); // For production
    return { __html: rawHtml }; // For dev, or if LLM output is trusted
};

const escapeHtml = (unsafe) => {
    if (typeof unsafe !== 'string') return '';
    return unsafe
         .replace(/&/g, "&")
         .replace(/</g, "<")
         .replace(/>/g, ">")
         .replace(/"/g, '"')
         .replace(/'/g, "'");
};


function MessageBubble({ sender, text, thinking, references, timestamp, sourcePipeline }) {
    const isUser = sender === 'user';

    const formatTimestamp = (ts) => {
        if (!ts) return '';
        try {
            return new Date(ts).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        } catch (e) { return ''; }
    };

    const getPipelineIcon = () => {
        if (!sourcePipeline) return null;
        if (sourcePipeline.includes('ollama')) return <Zap size={12} className="text-green-400" title="Ollama" />;
        if (sourcePipeline.includes('gemini')) return <Server size={12} className="text-blue-400" title="Gemini" />;
        return null;
    };

    return (
        <div className={`flex flex-col ${isUser ? 'items-end' : 'items-start'} w-full`}>
            <div 
                className={`message-bubble max-w-[85%] md:max-w-[75%] p-3 rounded-2xl shadow-md ${
                    isUser 
                    ? 'bg-primary dark:bg-primary-dark text-white rounded-br-lg' 
                    : 'bg-surface-light dark:bg-surface-dark text-text-light dark:text-text-dark rounded-bl-lg border border-gray-200 dark:border-gray-700'
                }`}
            >
                <div className="prose prose-sm dark:prose-invert max-w-none message-content" dangerouslySetInnerHTML={createMarkup(text || '')} />
                
                <div className="flex items-center justify-end mt-1.5 text-xs opacity-70">
                    {!isUser && getPipelineIcon() && <span className="mr-1.5">{getPipelineIcon()}</span>}
                    {formatTimestamp(timestamp)}
                </div>
            </div>

            {!isUser && (thinking || (references && references.length > 0)) && (
                <div className="message-metadata-container max-w-[85%] md:max-w-[75%] mt-1.5 pl-2">
                    {thinking && (
                        <details className="group text-xs mb-1">
                            <summary className="flex items-center gap-1 cursor-pointer text-text-muted-light dark:text-text-muted-dark hover:text-primary dark:hover:text-primary-light transition-colors">
                                <Brain size={14} /> Reasoning
                                <ChevronDown size={14} className="group-open:rotate-180 transition-transform" />
                            </summary>
                            <pre className="mt-1 p-2 bg-gray-100 dark:bg-gray-800 rounded-md text-text-light dark:text-text-dark whitespace-pre-wrap break-all text-[0.7rem] max-h-32 overflow-y-auto custom-scrollbar">
                                <code>{escapeHtml(thinking)}</code>
                            </pre>
                        </details>
                    )}
                    {references && references.length > 0 && (
                        <details className="group text-xs" open>
                            <summary className="flex items-center gap-1 cursor-pointer text-text-muted-light dark:text-text-muted-dark hover:text-primary dark:hover:text-primary-light transition-colors">
                                <LinkIcon size={14} /> References
                                <ChevronDown size={14} className="group-open:rotate-180 transition-transform" />
                            </summary>
                            <ul className="mt-1 pl-1 space-y-0.5 text-[0.7rem]">
                                {references.map((ref, index) => (
                                    <li 
                                        key={index} 
                                        className="text-text-muted-light dark:text-text-muted-dark hover:text-text-light dark:hover:text-text-dark transition-colors"
                                        title={`Preview: ${escapeHtml(ref.content_preview || '')}`}
                                    >
                                        <span className="font-semibold text-accent">[{ref.number}]</span> {escapeHtml(ref.source)}
                                    </li>
                                ))}
                            </ul>
                        </details>
                    )}
                </div>
            )}
        </div>
    );
}

export default MessageBubble;
```

`src/components/common/ThemeToggle.jsx`

```javascript
import React from 'react';
import { Sun, Moon } from 'lucide-react';
import { useTheme } from '../../hooks/useTheme';

function ThemeToggle() {
    const { theme, toggleTheme } = useTheme();

    return (
        <button
            onClick={toggleTheme}
            className="p-2 rounded-full text-text-muted-light dark:text-text-muted-dark hover:bg-gray-200 dark:hover:bg-gray-700 transition-colors focus:outline-none focus:ring-2 focus:ring-primary"
            aria-label={theme === 'light' ? 'Switch to dark theme' : 'Switch to light theme'}
        >
            {theme === 'light' ? <Moon size={20} /> : <Sun size={20} />}
        </button>
    );
}

export default ThemeToggle;
```

`src/components/core/Button.jsx`

```javascript
import React from 'react';
import { Loader2 } from 'lucide-react'; // For loading spinner

const Button = ({
    children,
    onClick,
    type = 'button',
    variant = 'primary', // 'primary', 'secondary', 'danger', 'outline', 'ghost'
    size = 'md', // 'sm', 'md', 'lg'
    leftIcon,
    rightIcon,
    isLoading = false,
    disabled = false,
    fullWidth = false,
    className = '',
    ...props
}) => {
    const baseStyles = "font-semibold rounded-lg focus:outline-none focus:ring-2 focus:ring-opacity-75 transition-all duration-150 ease-in-out flex items-center justify-center gap-2";

    const variantStyles = {
        primary: "bg-primary hover:bg-primary-dark text-white focus:ring-primary",
        secondary: "bg-secondary hover:bg-secondary-dark text-white focus:ring-secondary",
        danger: "bg-red-500 hover:bg-red-600 text-white focus:ring-red-500",
        outline: "border border-primary text-primary hover:bg-primary-light dark:hover:bg-opacity-10 focus:ring-primary",
        ghost: "text-primary hover:bg-primary-light dark:hover:bg-opacity-10 focus:ring-primary",
    };

    const sizeStyles = {
        sm: "px-3 py-1.5 text-xs",
        md: "px-4 py-2 text-sm",
        lg: "px-6 py-3 text-base",
    };

    const widthStyle = fullWidth ? "w-full" : "";
    const disabledStyle = (disabled || isLoading) ? "opacity-60 cursor-not-allowed" : "cursor-pointer";

    return (
        <button
            type={type}
            onClick={onClick}
            disabled={disabled || isLoading}
            className={`${baseStyles} ${variantStyles[variant]} ${sizeStyles[size]} ${widthStyle} ${disabledStyle} ${className}`}
            {...props}
        >
            {isLoading && <Loader2 size={size === 'sm' ? 14 : 18} className="animate-spin" />}
            {!isLoading && leftIcon && <span className="icon-left">{leftIcon}</span>}
            {!isLoading && children}
            {!isLoading && rightIcon && <span className="icon-right">{rightIcon}</span>}
        </button>
    );
};

export default Button;
```

`src/components/core/IconButton.jsx`

```javascript
import React from 'react';
import { Loader2 } from 'lucide-react';

const IconButton = ({
    icon: Icon, // Pass the Lucide icon component directly
    onClick,
    variant = 'ghost', // 'ghost', 'outline', 'subtle'
    size = 'md', // 'sm', 'md', 'lg'
    isLoading = false,
    disabled = false,
    className = '',
    title, // For accessibility and tooltips
    ariaLabel,
    ...props
}) => {
    const baseStyles = "rounded-md focus:outline-none focus:ring-2 focus:ring-opacity-75 transition-colors duration-150 flex items-center justify-center";

    const variantStyles = {
        ghost: "text-text-muted-light dark:text-text-muted-dark hover:bg-gray-200 dark:hover:bg-gray-700 focus:ring-primary",
        outline: "border border-gray-300 dark:border-gray-600 text-text-muted-light dark:text-text-muted-dark hover:border-primary hover:text-primary focus:ring-primary",
        subtle: "bg-gray-100 dark:bg-gray-700 text-text-light dark:text-text-dark hover:bg-gray-200 dark:hover:bg-gray-600 focus:ring-primary",
        danger: "text-red-500 hover:bg-red-100 dark:hover:bg-red-900 focus:ring-red-500"
    };

    const sizeStyles = {
        sm: "p-1.5", // Icon size typically 14-16px
        md: "p-2",   // Icon size typically 18-20px
        lg: "p-2.5", // Icon size typically 22-24px
    };
    
    const iconSizeMap = {
        sm: 16,
        md: 20,
        lg: 24,
    };

    const disabledStyle = (disabled || isLoading) ? "opacity-50 cursor-not-allowed" : "cursor-pointer";

    return (
        <button
            type="button"
            onClick={onClick}
            disabled={disabled || isLoading}
            className={`${baseStyles} ${variantStyles[variant]} ${sizeStyles[size]} ${disabledStyle} ${className}`}
            title={title}
            aria-label={ariaLabel || title}
            {...props}
        >
            {isLoading ? (
                <Loader2 size={iconSizeMap[size]} className="animate-spin" />
            ) : (
                Icon && <Icon size={iconSizeMap[size]} />
            )}
        </button>
    );
};

export default IconButton;
```

`src/components/core/Modal.jsx`

```javascript
import React, { useEffect } from 'react';
import { X } from 'lucide-react';
import { motion, AnimatePresence } from 'framer-motion';

const Modal = ({
    isOpen,
    onClose,
    title,
    children,
    footerContent,
    size = 'md', // 'sm', 'md', 'lg', 'xl'
    closeOnOverlayClick = true,
}) => {
    useEffect(() => {
        const handleEscapeKey = (event) => {
            if (event.key === 'Escape' && isOpen) {
                onClose();
            }
        };
        document.addEventListener('keydown', handleEscapeKey);
        return () => {
            document.removeEventListener('keydown', handleEscapeKey);
        };
    }, [isOpen, onClose]);

    const sizeClasses = {
        sm: 'max-w-sm',
        md: 'max-w-md',
        lg: 'max-w-lg',
        xl: 'max-w-xl',
        '2xl': 'max-w-2xl'
    };

    const backdropVariants = {
        visible: { opacity: 1 },
        hidden: { opacity: 0 },
    };

    const modalVariants = {
        hidden: { y: "-50px", opacity: 0 },
        visible: { y: "0", opacity: 1 },
        exit: { y: "50px", opacity: 0 }
    };

    if (!isOpen) return null;

    return (
        <AnimatePresence>
            {isOpen && (
                <motion.div
                    key="modal-backdrop"
                    className="fixed inset-0 z-50 flex items-center justify-center p-4 bg-black bg-opacity-75"
                    initial="hidden"
                    animate="visible"
                    exit="hidden"
                    variants={backdropVariants}
                    transition={{ duration: 0.2 }}
                    onClick={closeOnOverlayClick ? onClose : undefined}
                >
                    <motion.div
                        key="modal-content"
                        className={`bg-surface-light dark:bg-surface-dark rounded-xl shadow-2xl w-full ${sizeClasses[size]} flex flex-col max-h-[90vh]`}
                        role="dialog"
                        aria-modal="true"
                        aria-labelledby="modal-title"
                        initial="hidden"
                        animate="visible"
                        exit="exit"
                        variants={modalVariants}
                        transition={{ type: "spring", stiffness: 300, damping: 30, duration: 0.3 }}
                        onClick={(e) => e.stopPropagation()} // Prevent closing when clicking inside modal
                    >
                        {/* Modal Header */}
                        <div className="flex items-center justify-between px-6 py-4 border-b border-gray-200 dark:border-gray-700">
                            {title && (
                                <h2 id="modal-title" className="text-lg font-semibold text-text-light dark:text-text-dark">
                                    {title}
                                </h2>
                            )}
                            <button
                                onClick={onClose}
                                className="p-1 rounded-full text-text-muted-light dark:text-text-muted-dark hover:bg-gray-200 dark:hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-primary"
                                aria-label="Close modal"
                            >
                                <X size={20} />
                            </button>
                        </div>

                        {/* Modal Body */}
                        <div className="px-6 py-5 overflow-y-auto flex-grow custom-scrollbar">
                            {children}
                        </div>

                        {/* Modal Footer */}
                        {footerContent && (
                            <div className="px-6 py-4 border-t border-gray-200 dark:border-gray-700 flex justify-end gap-3">
                                {footerContent}
                            </div>
                        )}
                    </motion.div>
                </motion.div>
            )}
        </AnimatePresence>
    );
};

export default Modal;
```

`src/components/documents/DocumentList.jsx`

```javascript
import React, { useState, useEffect, useCallback } from 'react';
import api from '../../services/api';
import toast from 'react-hot-toast';
import { FileText, Edit3, Trash2, RefreshCw, Loader2, AlertTriangle } from 'lucide-react';
// You'll need a modal component for rename
// import RenameFileModal from './RenameFileModal'; 

function DocumentList() {
    const [files, setFiles] = useState([]);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState('');
    // const [showRenameModal, setShowRenameModal] = useState(false);
    // const [fileToRename, setFileToRename] = useState(null);

    const fetchFiles = useCallback(async () => {
        setLoading(true);
        setError('');
        try {
            const userFiles = await api.getFiles();
            setFiles(userFiles || []);
        } catch (err) {
            setError(err.message || "Failed to fetch documents.");
            toast.error("Could not load your documents.");
            console.error(err);
        } finally {
            setLoading(false);
        }
    }, []);

    useEffect(() => {
        fetchFiles();
    }, [fetchFiles]);

    const handleRename = async (file, newName) => {
        // This would be triggered by a modal
        if (!newName || newName === file.originalName) return;
        const toastId = toast.loading(`Renaming ${file.originalName}...`);
        try {
            await api.renameFile(file.serverFilename, newName);
            toast.success(`Renamed to ${newName}`, { id: toastId });
            fetchFiles(); // Refresh list
        } catch (err) {
            toast.error(`Rename failed: ${err.message}`, { id: toastId });
        }
    };

    const handleDelete = async (file) => {
        if (!window.confirm(`Are you sure you want to delete "${file.originalName}"? It will be moved to backup.`)) return;
        const toastId = toast.loading(`Deleting ${file.originalName}...`);
        try {
            await api.deleteFile(file.serverFilename);
            toast.success(`${file.originalName} moved to backup.`, { id: toastId });
            fetchFiles(); // Refresh list
        } catch (err) {
            toast.error(`Delete failed: ${err.message}`, { id: toastId });
        }
    };

    if (loading) {
        return (
            <div className="flex items-center justify-center p-4 text-text-muted-light dark:text-text-muted-dark">
                <Loader2 size={20} className="animate-spin mr-2" /> Loading documents...
            </div>
        );
    }

    if (error) {
        return (
            <div className="p-3 bg-red-100 dark:bg-red-900 border border-red-400 dark:border-red-700 text-red-700 dark:text-red-200 rounded-md text-sm flex items-center gap-2">
                <AlertTriangle size={18} /> {error} 
                <button onClick={fetchFiles} className="ml-auto text-xs underline">Retry</button>
            </div>
        );
    }
    
    if (files.length === 0) {
        return <p className="text-center text-xs text-text-muted-light dark:text-text-muted-dark p-4">No documents uploaded yet. Use the section above to add files.</p>;
    }

    // TODO: Implement document selection for analysis context.
    // This requires passing a callback or using context to inform App.js or AnalysisControls.jsx
    // of the selected document.

    return (
        <div className="space-y-1.5 text-xs custom-scrollbar">
            {files.map(file => (
                <div 
                    key={file.serverFilename} 
                    className="p-2 bg-surface-light dark:bg-gray-800 border border-gray-200 dark:border-gray-700 rounded-md flex items-center justify-between hover:shadow-md transition-shadow"
                    // onClick={() => onSelectDocument(file)} // Example of selection
                    // className={`... ${selectedDoc?.serverFilename === file.serverFilename ? 'ring-2 ring-primary' : ''}`}
                >
                    <div className="flex items-center gap-1.5 truncate">
                        <FileText size={16} className="text-primary flex-shrink-0" />
                        <span className="truncate" title={file.originalName}>{file.originalName}</span>
                    </div>
                    <div className="flex-shrink-0 flex items-center gap-1">
                        <button 
                            // onClick={(e) => { e.stopPropagation(); setFileToRename(file); setShowRenameModal(true); }} 
                            onClick={(e) => { e.stopPropagation(); const newN = prompt(`Rename "${file.originalName}" to:`, file.originalName); if(newN) handleRename(file, newN); }}
                            className="p-1 text-blue-500 hover:text-blue-700 dark:text-blue-400 dark:hover:text-blue-300" title="Rename">
                            <Edit3 size={14} />
                        </button>
                        <button onClick={(e) => { e.stopPropagation(); handleDelete(file);}} className="p-1 text-red-500 hover:text-red-700 dark:text-red-400 dark:hover:text-red-300" title="Delete">
                            <Trash2 size={14} />
                        </button>
                    </div>
                </div>
            ))}
            {/* <RenameFileModal isOpen={showRenameModal} onClose={() => setShowRenameModal(false)} file={fileToRename} onSave={handleRename} /> */}
        </div>
    );
}
export default DocumentList;

```

`src/components/documents/DocumentUpload.jsx`

```javascript
import React, { useState } from 'react';
import api from '../../services/api';
import toast from 'react-hot-toast';
import { UploadCloud, FileText, XCircle } from 'lucide-react';

function DocumentUpload({ onUploadSuccess }) {
    const [selectedFile, setSelectedFile] = useState(null);
    const [isUploading, setIsUploading] = useState(false);
    const [uploadProgress, setUploadProgress] = useState(0);
    const [dragActive, setDragActive] = useState(false);

    const handleFileChange = (e) => {
        if (e.target.files && e.target.files[0]) {
            setSelectedFile(e.target.files[0]);
        }
    };

    const handleDrag = (e) => {
        e.preventDefault();
        e.stopPropagation();
        if (e.type === "dragenter" || e.type === "dragover") {
            setDragActive(true);
        } else if (e.type === "dragleave") {
            setDragActive(false);
        }
    };

    const handleDrop = (e) => {
        e.preventDefault();
        e.stopPropagation();
        setDragActive(false);
        if (e.dataTransfer.files && e.dataTransfer.files[0]) {
            setSelectedFile(e.dataTransfer.files[0]);
        }
    };

    const handleUpload = async () => {
        if (!selectedFile) {
            toast.error("Please select a file first.");
            return;
        }
        setIsUploading(true);
        setUploadProgress(0);
        const toastId = toast.loading(`Uploading ${selectedFile.name}... 0%`);

        const formData = new FormData();
        formData.append('file', selectedFile);

        try {
            await api.uploadFile(formData, (progressEvent) => {
                const percent = Math.round((progressEvent.loaded * 100) / progressEvent.total);
                setUploadProgress(percent);
                toast.loading(`Uploading ${selectedFile.name}... ${percent}%`, { id: toastId });
            });
            toast.success(`${selectedFile.name} uploaded successfully! Document processing started.`, { id: toastId });
            setSelectedFile(null);
            if (onUploadSuccess) onUploadSuccess();
        } catch (error) {
            toast.error(`Upload failed: ${error.message || 'Unknown error'}`, { id: toastId });
            console.error("Upload failed:", error);
        } finally {
            setIsUploading(false);
            setUploadProgress(0);
        }
    };

    return (
        <div className="mb-4 p-1">
            <label 
                htmlFor="file-upload-input"
                onDragEnter={handleDrag} 
                onDragLeave={handleDrag} 
                onDragOver={handleDrag} 
                onDrop={handleDrop}
                className={`flex flex-col items-center justify-center w-full h-32 px-4 transition bg-surface-light dark:bg-gray-800 border-2 border-gray-300 dark:border-gray-600 border-dashed rounded-lg cursor-pointer hover:border-primary dark:hover:border-primary-light
                    ${dragActive ? "border-primary dark:border-primary-light ring-2 ring-primary" : ""}
                    ${isUploading ? "opacity-50 cursor-not-allowed" : ""}`}
            >
                <div className="flex flex-col items-center justify-center pt-5 pb-6 text-center">
                    <UploadCloud size={32} className={`mb-2 ${dragActive ? 'text-primary' : 'text-text-muted-light dark:text-text-muted-dark'}`} />
                    <p className="mb-1 text-xs text-text-muted-light dark:text-text-muted-dark">
                        <span className="font-semibold">Click to upload</span> or drag and drop
                    </p>
                    <p className="text-xs text-text-muted-light dark:text-text-muted-dark">PDF, DOCX, TXT, PPTX, code files</p>
                </div>
                <input id="file-upload-input" type="file" className="hidden" onChange={handleFileChange} disabled={isUploading} 
                       accept=".pdf,.doc,.docx,.ppt,.pptx,.txt,.py,.js,.md,.html,.xml,.json,.csv,.log" />
            </label>

            {selectedFile && (
                <div className="mt-2 p-2 bg-gray-100 dark:bg-gray-700 rounded-md flex items-center justify-between text-sm">
                    <div className="flex items-center gap-2 truncate">
                        <FileText size={18} className="text-primary flex-shrink-0" />
                        <span className="truncate" title={selectedFile.name}>{selectedFile.name}</span>
                        <span className="text-text-muted-light dark:text-text-muted-dark text-xs whitespace-nowrap">
                            ({(selectedFile.size / 1024).toFixed(1)} KB)
                        </span>
                    </div>
                    {!isUploading && (
                        <button onClick={() => setSelectedFile(null)} className="text-red-500 hover:text-red-700">
                            <XCircle size={18} />
                        </button>
                    )}
                </div>
            )}
            
            {isUploading && (
                <div className="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-1.5 mt-2">
                    <div className="bg-primary h-1.5 rounded-full transition-all duration-300 ease-linear" style={{ width: `${uploadProgress}%` }}></div>
                </div>
            )}

            <button
                onClick={handleUpload}
                className="w-full mt-2 btn-primary-custom text-sm py-1.5 disabled:opacity-60"
                disabled={!selectedFile || isUploading}
            >
                {isUploading ? `Uploading ${uploadProgress}%...` : "Upload Document"}
            </button>
        </div>
    );
}
export default DocumentUpload;
```

`src/components/layout/CenterPanel.jsx`

```javascript
// import React, { useState, useEffect } from 'react';
// import ChatHistory from '../chat/ChatHistory';
// import ChatInput from '../chat/ChatInput';
// import api from '../../services/api';
// import { useAuth } from '../../hooks/useAuth';
// import { useAppState } from '../../contexts/AppStateContext';
// import toast from 'react-hot-toast';

// function CenterPanel({ messages, setMessages, currentSessionId, chatStatus, setChatStatus }) {
//     const { token } = useAuth();
//     const { selectedLLM } = useAppState(); // To know which LLM is active
//     const [useRag, setUseRag] = useState(false); // Local state for RAG toggle in this panel
//     const [isSending, setIsSending] = useState(false);
    
//     const handleSendMessage = async (inputText) => {
//         if (!inputText.trim() || !token || isSending) return;

//         const userMessage = {
//             id: `user-${Date.now()}`,
//             sender: 'user',
//             text: inputText.trim(),
//             timestamp: new Date().toISOString()
//         };
//         setMessages(prev => [...prev, userMessage]);
        
//         setIsSending(true);
//         setChatStatus(useRag ? "Searching documents & Thinking (Ollama RAG)..." : "Thinking (Gemini)...");

//         try {
//             const historyForBackend = messages.map(m => ({ // Only previous messages
//                 role: m.sender === 'bot' ? 'model' : 'user',
//                 parts: [{ text: m.text }]
//             }));

//             const payload = {
//                 query: inputText.trim(),
//                 history: historyForBackend,
//                 sessionId: currentSessionId,
//                 useRag: useRag // This flag is crucial for the backend orchestrator
//             };
            
//             const response = await api.sendMessage(payload); // Token auto-included by axios interceptor
            
//             // currentSessionId is managed by App.js if backend returns a new one
//             // For now, assume session ID remains the same unless explicitly changed by App.js

//             const botReply = response.reply;
//             setMessages(prev => [...prev, {
//                 id: `bot-${Date.now()}`,
//                 sender: 'bot',
//                 text: botReply.parts[0]?.text,
//                 thinking: botReply.thinking,
//                 references: botReply.references || [],
//                 timestamp: botReply.timestamp,
//                 source_pipeline: response.source_pipeline // Useful for display
//             }]);
//             setChatStatus(`Responded via ${response.source_pipeline}.`);
//         } catch (error) {
//             console.error("Error sending message:", error);
//             const errorText = error.response?.data?.message || error.message || 'Failed to get response.';
//             setMessages(prev => [...prev, { 
//                 id: `error-${Date.now()}`, 
//                 sender: 'bot', 
//                 text: `Error: ${errorText}` 
//             }]);
//             setChatStatus(`Error: ${errorText}`);
//             toast.error(errorText);
//         } finally {
//             setIsSending(false);
//         }
//     };

//     return (
//         <div className="flex flex-col h-full bg-background-light dark:bg-background-dark rounded-lg shadow-inner">
//             {/* Welcome Message - Conditional */}
//             {messages.length === 0 && !isSending && (
//                  <div className="p-8 text-center text-text-muted-light dark:text-text-muted-dark animate-fadeIn">
//                     <h2 className="text-2xl font-semibold mb-2">HELLO MY FRIEND,</h2>
//                     <p className="text-lg">HOW CAN I ASSIST YOU TODAY?</p>
//                     <p className="text-sm mt-4">
//                         Toggle "Use My Documents" below to chat with your uploaded files using Ollama RAG,
//                         or chat directly with {selectedLLM.toUpperCase()} for general queries.
//                     </p>
//                 </div>
//             )}

//             <ChatHistory messages={messages} isLoading={isSending} />
//             <ChatInput 
//                 onSendMessage={handleSendMessage} 
//                 isLoading={isSending} 
//                 currentStatus={chatStatus}
//                 useRag={useRag}
//                 setUseRag={setUseRag}
//             />
//         </div>
//     );
// }
// export default CenterPanel;






// src/components/layout/CenterPanel.jsx
import React, { useState } from 'react';
import ChatHistory from '../chat/ChatHistory';
import ChatInput from '../chat/ChatInput';
import api from '../../services/api';
import { useAuth } from '../../hooks/useAuth';
import { useAppState } from '../../contexts/AppStateContext';
import toast from 'react-hot-toast';

function CenterPanel({ messages, setMessages, currentSessionId, chatStatus, setChatStatus }) {
    const { token } = useAuth();
    // Get systemPrompt from global state
    const { selectedLLM, systemPrompt } = useAppState(); 
    const [useRag, setUseRag] = useState(false); // RAG toggle state
    const [isSending, setIsSending] = useState(false);
    
    const handleSendMessage = async (inputText) => {
        if (!inputText.trim() || !token || isSending) return;

        const userMessage = {
            id: `user-${Date.now()}-${Math.random().toString(16).slice(2)}`,
            sender: 'user',
            text: inputText.trim(),
            timestamp: new Date().toISOString()
        };
        setMessages(prev => [...prev, userMessage]);
        
        setIsSending(true);
        let thinkingStatus = "Thinking...";
        if (useRag) {
            thinkingStatus = `Searching docs & Thinking (${selectedLLM.toUpperCase()} RAG)...`;
        } else {
            thinkingStatus = `Thinking (${selectedLLM.toUpperCase()})...`;
        }
        // Add system prompt to status if it's custom or not the default
        const defaultInitialPrompt = "You are a helpful AI engineering tutor."; // Or fetch from your presets
        if (systemPrompt && systemPrompt !== defaultInitialPrompt) {
            thinkingStatus += ` (Mode: ${systemPrompt.substring(0,25)}...)`;
        }
        setChatStatus(thinkingStatus);


        try {
            const historyForBackend = messages.map(m => ({
                role: m.sender === 'bot' ? 'model' : 'user',
                parts: [{ text: m.text }]
            }));

            const payload = {
                query: inputText.trim(),
                history: historyForBackend,
                sessionId: currentSessionId,
                useRag: useRag,
                llmProvider: selectedLLM, // Send the selected LLM provider
                systemPrompt: systemPrompt // Send the current system prompt text
            };
            
            const response = await api.sendMessage(payload);
            
            const botReply = response.reply;
            if (botReply && botReply.parts && botReply.parts.length > 0) {
                setMessages(prev => [...prev, {
                    id: `bot-${Date.now()}-${Math.random().toString(16).slice(2)}`,
                    sender: 'bot',
                    text: botReply.parts[0]?.text,
                    thinking: botReply.thinking,
                    references: botReply.references || [],
                    timestamp: botReply.timestamp || new Date().toISOString(),
                    source_pipeline: response.source_pipeline
                }]);
                setChatStatus(`Responded via ${response.source_pipeline || selectedLLM.toUpperCase()}.`);
            } else {
                throw new Error("Invalid response structure from AI.");
            }

        } catch (error) {
            console.error("Error sending message:", error);
            const errorText = error.response?.data?.message || error.message || 'Failed to get response.';
            setMessages(prev => [...prev, { 
                id: `error-${Date.now()}-${Math.random().toString(16).slice(2)}`, 
                sender: 'bot', 
                text: `Error: ${errorText}`,
                timestamp: new Date().toISOString()
            }]);
            setChatStatus(`Error: ${errorText.substring(0,50)}...`);
            toast.error(errorText);
        } finally {
            setIsSending(false);
        }
    };

    return (
        <div className="flex flex-col h-full bg-background-light dark:bg-background-dark rounded-lg shadow-inner">
            {messages.length === 0 && !isSending && (
                 <div className="p-6 sm:p-8 text-center text-text-muted-light dark:text-text-muted-dark animate-fadeIn">
                    <h2 className="text-xl sm:text-2xl font-semibold mb-2 text-text-light dark:text-text-dark">HELLO MY FRIEND,</h2>
                    <p className="text-base sm:text-lg mb-3">HOW CAN I ASSIST YOU TODAY?</p>
                    <div className="text-xs sm:text-sm space-y-1">
                        <p>
                            Current LLM: <span className="font-semibold text-accent">{selectedLLM.toUpperCase()}</span>.
                        </p>
                        <p className="max-w-md mx-auto">
                            Assistant Mode: <span className="italic">"{systemPrompt.length > 60 ? systemPrompt.substring(0,60)+'...' : systemPrompt}"</span>
                        </p>
                        <p className="mt-2">
                            Toggle "Use My Docs" below for RAG-enhanced chat.
                        </p>
                    </div>
                </div>
            )}

            <ChatHistory messages={messages} isLoading={isSending} />
            <ChatInput 
                onSendMessage={handleSendMessage} 
                isLoading={isSending} 
                currentStatus={chatStatus}
                useRag={useRag}
                setUseRag={setUseRag}
            />
        </div>
    );
}
export default CenterPanel;
```

`src/components/layout/LeftCollapsedNav.jsx`

```javascript
// frontend/src/components/layout/LeftCollapsedNav.jsx
import React from 'react';
import { useAppState } from '../../contexts/AppStateContext.jsx'; // Ensure .jsx
import { Edit3, UploadCloud, FileText, ChevronRight } from 'lucide-react';
import IconButton from '../core/IconButton.jsx'; // Ensure .jsx
import { motion } from 'framer-motion';

const iconMap = {
    prompt: Edit3,
    upload: UploadCloud,
    docs: FileText,
};

function LeftCollapsedNav() {
    const { setIsLeftPanelOpen } = useAppState();

    const navItems = [
        { id: 'prompt', label: 'Custom Prompt', iconName: 'Edit3', action: () => { setIsLeftPanelOpen(true); } },
        { id: 'upload', label: 'Upload Document', iconName: 'UploadCloud', action: () => { setIsLeftPanelOpen(true); } },
        { id: 'docs', label: 'Document List', iconName: 'FileText', action: () => { setIsLeftPanelOpen(true); } },
    ];

    return (
        <motion.aside
            key="left-collapsed-nav"
            initial={{ x: '-100%', opacity: 0 }}
            animate={{ x: '0%', opacity: 1 }}
            exit={{ x: '-100%', opacity: 0 }}
            transition={{ type: 'spring', stiffness: 260, damping: 30, duration: 0.2 }}
            // Use fixed positioning to overlay or sit beside content
            // top-16 to account for TopNav height, bottom-0 to fill height
            // z-30 to be above content but below modals
            // w-14 for smaller screens, sm:w-16 for slightly larger
            className="fixed left-0 top-16 bottom-0 z-30 w-14 sm:w-16 bg-surface-light dark:bg-surface-dark border-r border-border-light dark:border-border-dark shadow-md flex flex-col items-center py-4 space-y-3 custom-scrollbar"
        >
            {navItems.map(item => {
                const Icon = iconMap[item.iconName] || Edit3; // Fallback icon
                return (
                    <IconButton 
                        key={item.id}
                        icon={Icon} // Pass the component directly
                        onClick={item.action}
                        title={item.label}
                        ariaLabel={item.label}
                        variant="ghost"
                        size="md" 
                        className="text-text-muted-light dark:text-text-muted-dark hover:text-primary dark:hover:text-primary-light"
                    />
                );
            })}
            <div className="mt-auto flex-grow flex items-end pb-2"> {/* Pushes open button to bottom */}
                <IconButton 
                    icon={ChevronRight}
                    onClick={() => setIsLeftPanelOpen(true)}
                    title="Open Assistant Panel"
                    ariaLabel="Open Assistant Panel"
                    variant="ghost"
                    size="md"
                    className="text-text-muted-light dark:text-text-muted-dark hover:text-primary dark:hover:text-primary-light"
                />
            </div>
        </motion.aside>
    );
}
export default LeftCollapsedNav;
```

`src/components/layout/LeftPanel.jsx`

```javascript
// import React, { useState } from 'react';
// import DocumentUpload from '../documents/DocumentUpload';
// import DocumentList from '../documents/DocumentList';
// import { ChevronDown, ChevronUp, FilePlus, ListFilter, Settings2 } from 'lucide-react'; // Example icons

// function LeftPanel() {
//     const [isPromptSectionOpen, setIsPromptSectionOpen] = useState(true);
//     const [systemPrompt, setSystemPrompt] = useState("You are a helpful AI engineering tutor."); // Default system prompt
//     const [isDocManagementOpen, setIsDocManagementOpen] = useState(true);

//     // TODO: Fetch and manage document list state, pass to DocumentList & DocumentUpload
//     // TODO: Implement prompt management (save/load presets)

//     return (
//         <div className="flex flex-col h-full">
//             {/* Custom Prompt Section */}
//             <div className="mb-4">
//                 <button 
//                     onClick={() => setIsPromptSectionOpen(!isPromptSectionOpen)}
//                     className="w-full flex items-center justify-between px-3 py-2 text-sm font-medium text-left text-text-light dark:text-text-dark bg-gray-100 dark:bg-gray-700 hover:bg-gray-200 dark:hover:bg-gray-600 rounded-md focus:outline-none"
//                 >
//                     <span><Settings2 size={16} className="inline mr-2" /> Custom Prompt</span>
//                     {isPromptSectionOpen ? <ChevronUp size={18} /> : <ChevronDown size={18} />}
//                 </button>
//                 {isPromptSectionOpen && (
//                     <div className="mt-2 p-3 bg-surface-light dark:bg-surface-dark border border-gray-200 dark:border-gray-600 rounded-md animate-fadeIn">
//                         {/* Dropdown for prompt presets - To be implemented */}
//                         <textarea
//                             value={systemPrompt}
//                             onChange={(e) => setSystemPrompt(e.target.value)}
//                             rows="3"
//                             className="input-custom text-xs"
//                             placeholder="Enter system prompt (e.g., Act as an expert in thermodynamics...)"
//                         />
//                         {/* Buttons for Save/Load prompt presets */}
//                     </div>
//                 )}
//             </div>

//             {/* Document Management Section */}
//             <div className="flex-grow flex flex-col overflow-hidden">
//                  <button 
//                     onClick={() => setIsDocManagementOpen(!isDocManagementOpen)}
//                     className="w-full flex items-center justify-between px-3 py-2 text-sm font-medium text-left text-text-light dark:text-text-dark bg-gray-100 dark:bg-gray-700 hover:bg-gray-200 dark:hover:bg-gray-600 rounded-md focus:outline-none mb-2"
//                 >
//                     <span><FilePlus size={16} className="inline mr-2" /> Document Management</span>
//                     {isDocManagementOpen ? <ChevronUp size={18} /> : <ChevronDown size={18} />}
//                 </button>
//                 {isDocManagementOpen && (
//                     <div className="flex-grow flex flex-col overflow-hidden animate-fadeIn">
//                         <DocumentUpload onUploadSuccess={() => { /* TODO: refresh doc list */ }} />
//                         <div className="mt-3 flex-grow overflow-y-auto">
//                              {/* SELECT DOCUMENT with filter dropdown - placeholder */}
//                             <div className="mb-2">
//                                 <label htmlFor="doc-filter" className="text-xs text-text-muted-light dark:text-text-muted-dark">Filter documents:</label>
//                                 <select id="doc-filter" className="input-custom input-custom text-xs mt-1">
//                                     <option value="all">All Documents</option>
//                                     <option value="pdf">PDFs</option>
//                                     {/* More filter options */}
//                                 </select>
//                             </div>
//                             <DocumentList />
//                         </div>
//                     </div>
//                 )}
//             </div>
//              {/* TODO: Document Preview Capabilities - complex, maybe a modal or dedicated view */}
//         </div>
//     );
// }
// export default LeftPanel;









// frontend/src/components/layout/LeftPanel.jsx
import React, { useState, useEffect } from 'react';
import { useAppState } from '../../contexts/AppStateContext';
import DocumentUpload from '../documents/DocumentUpload.jsx'; // Added .jsx
import DocumentList from '../documents/DocumentList.jsx';   // Added .jsx
import { PanelLeftClose, ChevronDown, ChevronUp, FilePlus, Settings2, Bot, BookOpen, Lightbulb } from 'lucide-react';
import IconButton from '../core/IconButton.jsx';         // Added .jsx
import { motion } from 'framer-motion';

const PROMPT_PRESETS = [ /* ... as defined in that response ... */ ];
// ... (PROMPT_PRESETS array as defined previously)

function LeftPanel() {
    const { setIsLeftPanelOpen, systemPrompt, setSystemPrompt, selectDocumentForAnalysis, selectedDocumentForAnalysis } = useAppState();
    
    const [isPromptSectionOpen, setIsPromptSectionOpen] = useState(true);
    const [isDocManagementOpen, setIsDocManagementOpen] = useState(true);
    const [selectedPresetId, setSelectedPresetId] = useState('custom');

    useEffect(() => {
        const matchedPreset = PROMPT_PRESETS.find(p => p.text === systemPrompt);
        setSelectedPresetId(matchedPreset ? matchedPreset.id : 'custom');
    }, [systemPrompt]);

    const handlePresetChange = (event) => {
        const presetId = event.target.value;
        setSelectedPresetId(presetId);
        const selectedPreset = PROMPT_PRESETS.find(p => p.id === presetId);
        if (selectedPreset) {
            setSystemPrompt(selectedPreset.text);
        }
    };
    
    const [docListKey, setDocListKey] = useState(Date.now()); 
    const handleUploadSuccess = () => { setDocListKey(Date.now()); };

    return (
        <div className="flex flex-col h-full">
            <div className="flex items-center justify-between mb-3 px-1 pt-1">
                <h2 className="text-sm font-semibold text-text-light dark:text-text-dark">Assistant Controls</h2>
                <IconButton 
                    icon={PanelLeftClose} 
                    onClick={() => setIsLeftPanelOpen(false)} 
                    title="Close Assistant Panel"
                    variant="ghost"
                    size="sm"
                    className="text-text-muted-light dark:text-text-muted-dark hover:text-primary"
                />
            </div>

            {/* Custom Prompt Section */}
            <div className="mb-4">
                <button 
                    onClick={() => setIsPromptSectionOpen(!isPromptSectionOpen)}
                    className="w-full flex items-center justify-between px-3 py-2.5 text-sm font-medium text-left text-text-light dark:text-text-dark bg-surface-light dark:bg-gray-800 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-md focus:outline-none shadow-sm border border-border-light dark:border-border-dark"
                >
                    <span className="flex items-center gap-2">
                        {(PROMPT_PRESETS.find(p=>p.id === selectedPresetId)?.icon || Settings2)({ size: 16 })}
                        Custom Prompt
                    </span>
                    {isPromptSectionOpen ? <ChevronUp size={18} /> : <ChevronDown size={18} />}
                </button>
                {isPromptSectionOpen && (
                    <motion.div 
                        initial={{ height: 0, opacity: 0 }} animate={{ height: 'auto', opacity: 1 }} exit={{ height: 0, opacity: 0 }}
                        transition={{ duration: 0.2 }}
                        className="mt-2 p-3 bg-surface-light dark:bg-surface-dark border border-border-light dark:border-border-dark rounded-md shadow-inner"
                    >
                        <label htmlFor="prompt-preset-select" className="block text-xs font-medium text-text-muted-light dark:text-text-muted-dark mb-1">
                            Prompt Mode:
                        </label>
                        <select
                            id="prompt-preset-select"
                            value={selectedPresetId}
                            onChange={handlePresetChange}
                            className="input-field mb-2 text-xs py-1.5"
                        >
                            {PROMPT_PRESETS.map(preset => (
                                <option key={preset.id} value={preset.id}>{preset.name}</option>
                            ))}
                        </select>
                        
                        <label htmlFor="system-prompt-area" className="block text-xs font-medium text-text-muted-light dark:text-text-muted-dark mb-1">
                            System Prompt (Editable):
                        </label>
                        <textarea
                            id="system-prompt-area"
                            value={systemPrompt}
                            onChange={(e) => {
                                setSystemPrompt(e.target.value);
                                setSelectedPresetId('custom');
                            }}
                            rows="5"
                            className="input-field text-xs custom-scrollbar"
                            placeholder="Enter system prompt..."
                        />
                    </motion.div>
                )}
            </div>

            {/* Document Management Section */}
            <div className="flex-grow flex flex-col overflow-hidden">
                 <button 
                    onClick={() => setIsDocManagementOpen(!isDocManagementOpen)}
                    className="w-full flex items-center justify-between px-3 py-2.5 text-sm font-medium text-left text-text-light dark:text-text-dark bg-surface-light dark:bg-gray-800 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-md focus:outline-none shadow-sm border border-border-light dark:border-border-dark mb-2"
                >
                    <span className="flex items-center gap-2"><FilePlus size={16} /> Document Management</span>
                    {isDocManagementOpen ? <ChevronUp size={18} /> : <ChevronDown size={18} />}
                </button>
                {isDocManagementOpen && (
                    <motion.div 
                        initial={{ height: 0, opacity: 0 }} animate={{ height: 'auto', opacity: 1 }} exit={{ height: 0, opacity: 0 }}
                        transition={{ duration: 0.2 }}
                        className="flex-grow flex flex-col overflow-hidden p-3 bg-surface-light dark:bg-surface-dark border border-border-light dark:border-border-dark rounded-md shadow-inner"
                    >
                        <DocumentUpload onUploadSuccess={handleUploadSuccess} />
                        <div className="mt-3 flex-grow overflow-y-auto custom-scrollbar">
                            <label htmlFor="doc-filter" className="text-xs text-text-muted-light dark:text-text-muted-dark">Filter documents:</label>
                             <select id="doc-filter" className="input-field text-xs mt-1 mb-2 py-1.5">
                                <option value="all">All Documents</option>
                                <option value="pdf">PDFs</option>
                            </select>
                            <DocumentList 
                                key={docListKey}
                                onSelectDocument={selectDocumentForAnalysis}
                                selectedDocument={selectedDocumentForAnalysis}
                            />
                        </div>
                    </motion.div>
                )}
            </div>
        </div>
    );
}
export default LeftPanel;
```

`src/components/layout/LLMSelectionModal.jsx`

```javascript
import React, { useState, useEffect } from 'react';
import { X, HardDrive, Cloud, Save, AlertCircle } from 'lucide-react';
import api from '../../services/api';
import toast from 'react-hot-toast';
import { useAppState } from '../../contexts/AppStateContext';

function LLMSelectionModal({ isOpen, onClose, currentLLM, onSelectLLM }) {
    const { switchLLM: setGlobalLLM } = useAppState();
    const [selectedProvider, setSelectedProvider] = useState(currentLLM);
    const [geminiApiKey, setGeminiApiKey] = useState('');
    const [loading, setLoading] = useState(false);
    const [error, setError] = useState('');

    useEffect(() => {
        setSelectedProvider(currentLLM); // Sync with global state when modal opens
        setGeminiApiKey(''); // Clear API key field
        setError('');
    }, [isOpen, currentLLM]);

    const handleSave = async () => {
        setLoading(true);
        setError('');
        toast.loading('Saving LLM preference...');

        try {
            if (selectedProvider === 'gemini' && !geminiApiKey.trim()) {
                // If switching to Gemini and no API key is provided, we can still switch
                // but the Gemini functionality will fail if the backend doesn't have a key.
                // OR, enforce API key input here if that's the desired flow.
                // For now, let's allow switching and let backend handle key presence.
                // A better UX might be to prompt for the key only if it's not already configured.
            }
            
            // Call backend to update user's LLM preference & API key if provided
            // Backend needs to securely store this.
            await api.updateUserLLMConfig({ 
                llmProvider: selectedProvider, 
                apiKey: selectedProvider === 'gemini' ? geminiApiKey.trim() : undefined 
            });

            setGlobalLLM(selectedProvider); // Update global app state
            onSelectLLM(selectedProvider); // Inform parent (TopNav)
            toast.dismiss();
            toast.success(`Switched to ${selectedProvider.toUpperCase()} LLM.`);
            onClose();
        } catch (err) {
            toast.dismiss();
            const errorMessage = err.response?.data?.message || err.message || 'Failed to update LLM preference.';
            setError(errorMessage);
            toast.error(errorMessage);
        } finally {
            setLoading(false);
        }
    };

    if (!isOpen) return null;

    return (
        <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 p-4 animate-fadeIn">
            <div className="bg-surface-light dark:bg-surface-dark p-6 sm:p-8 rounded-xl shadow-2xl w-full max-w-lg transform transition-all">
                <div className="flex justify-between items-center mb-6">
                    <h2 className="text-xl font-semibold text-text-light dark:text-text-dark">
                        Switch LLM Provider
                    </h2>
                    <button onClick={onClose} className="text-text-muted-light dark:text-text-muted-dark hover:text-red-500 transition-colors">
                        <X size={24} />
                    </button>
                </div>

                {error && <div className="mb-4 p-3 bg-red-100 dark:bg-red-900 border border-red-400 dark:border-red-700 text-red-700 dark:text-red-200 rounded-md text-sm flex items-center gap-2"><AlertCircle size={18}/> {error}</div>}

                <div className="space-y-4">
                    <p className="text-sm text-text-muted-light dark:text-text-muted-dark">
                        Select your preferred Large Language Model provider. Your choice will be saved for future sessions.
                    </p>
                    
                    <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
                        {['ollama', 'gemini'].map(provider => (
                            <button
                                key={provider}
                                type="button"
                                onClick={() => setSelectedProvider(provider)}
                                className={`p-4 border rounded-lg text-left transition-all duration-150 focus:outline-none
                                    ${selectedProvider === provider 
                                        ? 'bg-primary-light dark:bg-primary-dark border-primary dark:border-primary-light ring-2 ring-primary dark:ring-primary-light shadow-lg' 
                                        : 'bg-surface-light dark:bg-surface-dark border-gray-300 dark:border-gray-600 hover:border-primary-light dark:hover:border-primary-dark hover:shadow-md'
                                    }`}
                            >
                                <div className="flex items-center mb-1">
                                    {provider === 'ollama' ? <HardDrive size={20} className={`mr-2 ${selectedProvider === provider ? 'text-primary dark:text-primary-light' : 'text-text-muted-light dark:text-text-muted-dark'}`} /> : <Cloud size={20} className={`mr-2 ${selectedProvider === provider ? 'text-primary dark:text-primary-light' : 'text-text-muted-light dark:text-text-muted-dark'}`} />}
                                    <span className={`font-semibold ${selectedProvider === provider ? 'text-primary dark:text-primary-light' : 'text-text-light dark:text-text-dark'}`}>
                                        {provider.toUpperCase()} LLM
                                    </span>
                                </div>
                                <p className={`text-xs ${selectedProvider === provider ? 'text-primary-dark dark:text-primary' : 'text-text-muted-light dark:text-text-muted-dark'}`}>
                                    {provider === 'ollama' ? 'Local & Private. Requires Ollama running.' : 'Cloud-based by Google. API Key may be required.'}
                                </p>
                            </button>
                        ))}
                    </div>

                    {selectedProvider === 'gemini' && (
                        <div className="mt-4">
                            <label htmlFor="modalGeminiApiKey" className="block text-sm font-medium text-text-light dark:text-text-dark mb-1">
                                Gemini API Key (if not already configured)
                            </label>
                            <input
                                type="password"
                                id="modalGeminiApiKey"
                                className="input-custom"
                                placeholder="Enter new or update existing Gemini API Key"
                                value={geminiApiKey}
                                onChange={(e) => setGeminiApiKey(e.target.value)}
                                disabled={loading}
                            />
                            <p className="text-xs text-text-muted-light dark:text-text-muted-dark mt-1">
                                Leave blank to use previously saved key. Provided key will be securely stored by the backend.
                            </p>
                        </div>
                    )}
                </div>

                <div className="mt-8 flex justify-end gap-3">
                    <button
                        type="button"
                        onClick={onClose}
                        className="px-4 py-2 text-sm font-medium rounded-md text-text-light dark:text-text-dark bg-gray-200 dark:bg-gray-600 hover:bg-gray-300 dark:hover:bg-gray-500 transition-colors"
                        disabled={loading}
                    >
                        Cancel
                    </button>
                    <button
                        type="button"
                        onClick={handleSave}
                        className="btn-primary-custom flex items-center justify-center gap-2"
                        disabled={loading}
                    >
                        {loading ? (
                            <span className="animate-spin rounded-full h-4 w-4 border-t-2 border-b-2 border-white"></span>
                        ) : (
                            <Save size={18} />
                        )}
                        Save Preference
                    </button>
                </div>
            </div>
        </div>
    );
}
export default LLMSelectionModal;
```

`src/components/layout/RightCollapsedNav.jsx`

```javascript
// frontend/src/components/layout/RightCollapsedNav.jsx
import React from 'react';
import { useAppState } from '../../contexts/AppStateContext.jsx'; // Ensure .jsx
import { HelpCircle, GitFork, Tags, ChevronLeft } from 'lucide-react';
import IconButton from '../core/IconButton.jsx'; // Ensure .jsx
import { motion } from 'framer-motion';

const iconMap = {
    faq: HelpCircle,
    topics: Tags,
    mindmap: GitFork,
};

function RightCollapsedNav() {
    const { setIsRightPanelOpen } = useAppState();

    const navItems = [
        { id: 'faq', label: 'FAQ Generator', iconName: 'HelpCircle', action: () => { setIsRightPanelOpen(true); } },
        { id: 'topics', label: 'Key Topics', iconName: 'Tags', action: () => { setIsRightPanelOpen(true); } },
        { id: 'mindmap', label: 'Mind Map', iconName: 'GitFork', action: () => { setIsRightPanelOpen(true); } },
    ];

    return (
        <motion.aside
            key="right-collapsed-nav"
            initial={{ x: '100%', opacity: 0 }}
            animate={{ x: '0%', opacity: 1 }}
            exit={{ x: '100%', opacity: 0 }}
            transition={{ type: 'spring', stiffness: 260, damping: 30, duration: 0.2 }}
            // Use fixed positioning
            className="fixed right-0 top-16 bottom-0 z-30 w-14 sm:w-16 bg-surface-light dark:bg-surface-dark border-l border-border-light dark:border-border-dark shadow-md flex-col items-center py-4 space-y-3 custom-scrollbar hidden md:flex" // hidden on small screens, flex on md and up
        >
            {navItems.map(item => {
                const Icon = iconMap[item.iconName] || HelpCircle; // Fallback icon
                return (
                    <IconButton 
                        key={item.id}
                        icon={Icon} // Pass the component directly
                        onClick={item.action}
                        title={item.label}
                        ariaLabel={item.label}
                        variant="ghost"
                        size="md"
                        className="text-text-muted-light dark:text-text-muted-dark hover:text-primary dark:hover:text-primary-light"
                    />
                );
            })}
             <div className="mt-auto flex-grow flex items-end pb-2">
                <IconButton 
                    icon={ChevronLeft}
                    onClick={() => setIsRightPanelOpen(true)}
                    title="Open Analyzer Panel"
                    ariaLabel="Open Analyzer Panel"
                    variant="ghost"
                    size="md"
                    className="text-text-muted-light dark:text-text-muted-dark hover:text-primary dark:hover:text-primary-light"
                />
            </div>
        </motion.aside>
    );
}
export default RightCollapsedNav;
```

`src/components/layout/RightPanel.jsx`

```javascript
// import React, { useState } from 'react';
// import AnalysisTool from '../analysis/AnalysisTool';
// import { ChevronDown, ChevronUp, Telescope } from 'lucide-react'; // Example icons

// function RightPanel() {
//     const [isAnalyzerOpen, setIsAnalyzerOpen] = useState(true);
//     // TODO: Manage state for selected document for analysis, analysis results for each tool

//     return (
//         <div className="flex flex-col h-full">
//             <button 
//                 onClick={() => setIsAnalyzerOpen(!isAnalyzerOpen)}
//                 className="w-full flex items-center justify-between px-3 py-2 text-sm font-medium text-left text-text-light dark:text-text-dark bg-gray-100 dark:bg-gray-700 hover:bg-gray-200 dark:hover:bg-gray-600 rounded-md focus:outline-none mb-2"
//             >
//                 <span><Telescope size={16} className="inline mr-2" /> Advanced Analyzer</span>
//                 {isAnalyzerOpen ? <ChevronUp size={18} /> : <ChevronDown size={18} />}
//             </button>

//             {isAnalyzerOpen && (
//                 <div className="flex-grow space-y-3 overflow-y-auto animate-fadeIn p-1">
//                     {/* 
//                         Here you'd pass the selected document from LeftPanel (or a global context) 
//                         to each AnalysisTool instance. This requires more state management.
//                         For simplicity, AnalysisTool will internally manage its state for now.
//                     */}
//                     <AnalysisTool toolType="faq" title="FAQ Generator" icon="HelpCircle" />
//                     <AnalysisTool toolType="topics" title="Key Topics Extractor" icon="Tags" />
//                     <AnalysisTool toolType="mindmap" title="Mind Map Creator" icon="GitFork" />
//                 </div>
//             )}
//         </div>
//     );
// }
// export default RightPanel;












// frontend/src/components/layout/RightPanel.jsx
import React, { useState } from 'react';
import { useAppState } from '../../contexts/AppStateContext';
import AnalysisTool from '../analysis/AnalysisTool.jsx'; // Added .jsx
import { PanelRightClose, ChevronDown, ChevronUp, Telescope } from 'lucide-react';
import IconButton from '../core/IconButton.jsx'; // Added .jsx
import { motion } from 'framer-motion';

function RightPanel() {
    const { setIsRightPanelOpen, selectedDocumentForAnalysis } = useAppState();
    const [isAnalyzerOpen, setIsAnalyzerOpen] = useState(true);

    const currentSelectedDocFilename = selectedDocumentForAnalysis?.originalName || null;

    return (
        <div className="flex flex-col h-full p-3 sm:p-4 bg-surface-light dark:bg-surface-dark text-text-light dark:text-text-dark custom-scrollbar">
            <div className="flex items-center justify-between mb-4 pb-2 border-b border-border-light dark:border-border-dark">
                <h2 className="text-base font-semibold">Advanced Analyzer</h2>
                <IconButton 
                    icon={PanelRightClose} 
                    onClick={() => setIsRightPanelOpen(false)} 
                    title="Close Analyzer Panel"
                    variant="ghost"
                    size="sm"
                    className="text-text-muted-light dark:text-text-muted-dark hover:text-primary dark:hover:text-primary-light"
                />
            </div>
            
            <button 
                onClick={() => setIsAnalyzerOpen(!isAnalyzerOpen)}
                className="w-full flex items-center justify-between px-3 py-2.5 text-sm font-medium text-left bg-gray-50 dark:bg-gray-800 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-md focus:outline-none shadow-sm border border-border-light dark:border-border-dark mb-3"
            >
                <span className="flex items-center gap-2"><Telescope size={16} /> Analysis Tools</span>
                {isAnalyzerOpen ? <ChevronUp size={18} /> : <ChevronDown size={18} />}
            </button>

            {isAnalyzerOpen && (
                <motion.div 
                    initial={{ height: 0, opacity: 0 }} 
                    animate={{ height: 'auto', opacity: 1 }} 
                    exit={{ height: 0, opacity: 0 }}
                    transition={{ duration: 0.2, ease: "easeInOut" }}
                    className="flex-grow space-y-3 overflow-y-auto custom-scrollbar pr-1"
                >
                    {!currentSelectedDocFilename && (
                        <div className="p-4 text-xs text-center text-text-muted-light dark:text-text-muted-dark bg-gray-50 dark:bg-gray-800 rounded-md border border-dashed border-border-light dark:border-border-dark">
                            <p>Select a document from the left panel to enable analysis tools.</p>
                        </div>
                    )}
                    <AnalysisTool toolType="faq" title="FAQ Generator" iconName="HelpCircle" selectedDocumentFilename={currentSelectedDocFilename} />
                    <AnalysisTool toolType="topics" title="Key Topics Extractor" iconName="Tags" selectedDocumentFilename={currentSelectedDocFilename} />
                    <AnalysisTool toolType="mindmap" title="Mind Map Creator" iconName="GitFork" selectedDocumentFilename={currentSelectedDocFilename} />
                </motion.div>
            )}
        </div>
    );
}
export default RightPanel;
```

`src/components/layout/TopNav.jsx`

```javascript
// import React, { useState } from 'react';
// import { useAuth } from '../../hooks/useAuth';
// import { useAppState } from '../../contexts/AppStateContext';
// import ThemeToggle from '../common/ThemeToggle';
// import { LogOut, User, MessageSquare, History, Settings, Cpu, Zap, ServerCrash, Server } from 'lucide-react'; // Cpu for LLM, Zap for Online, ServerCrash for Offline
// import LLMSelectionModal from './LLMSelectionModal'; // New component for LLM switching

// function TopNav({ onNewChat, onHistoryClick, orchestratorStatus }) {
//     const { user, logout } = useAuth();
//     const { selectedLLM, switchLLM, setIsLeftPanelOpen, setIsRightPanelOpen, isLeftPanelOpen, isRightPanelOpen } = useAppState();
//     const [isLLMModalOpen, setIsLLMModalOpen] = useState(false);
    
//     const getStatusIndicator = () => {
//         if (orchestratorStatus.status === "ok") {
//             return <Zap size={18} className="text-green-400 animate-pulse" title="Backend Online" />;
//         } else if (orchestratorStatus.status === "loading") {
//             return <div className="animate-spin rounded-full h-4 w-4 border-t-2 border-b-2 border-yellow-400" title="Connecting..."></div>;
//         } else {
//             return <ServerCrash size={18} className="text-red-400" title={`Backend Offline: ${orchestratorStatus.message}`} />;
//         }
//     };

//     return (
//         <>
//             <nav className="fixed top-0 left-0 right-0 z-40 bg-surface-light dark:bg-surface-dark border-b border-gray-200 dark:border-gray-700 shadow-sm h-16 flex items-center justify-between px-4 sm:px-6">
//                 {/* Left Side: Branding & Panel Toggles */}
//                 <div className="flex items-center gap-2">
//                      <button 
//                         onClick={() => setIsLeftPanelOpen(prev => !prev)} 
//                         className="p-2 rounded-md hover:bg-gray-200 dark:hover:bg-gray-700 lg:hidden"
//                         title={isLeftPanelOpen ? "Close Assistant Panel" : "Open Assistant Panel"} 
//                         aria-label="Toggle Assistant Panel"
//                     >
//                         <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d={isLeftPanelOpen ? "M6 18L18 6M6 6l12 12" : "M4 6h16M4 12h16M4 18h7"}></path></svg>
//                     </button>
//                     <a href="/" className="flex items-center gap-2 text-xl font-semibold text-text-light dark:text-text-dark">
//                         {/* Replace with your logo if you have one */}
//                         <Server size={28} className="text-primary dark:text-primary-light" />
//                         <span>AI Tutor</span>
//                     </a>
//                 </div>

//                 {/* Center Controls */}
//                 <div className="hidden md:flex items-center gap-2">
//                     <button
//                         onClick={onNewChat}
//                         className="flex items-center gap-1.5 px-3 py-1.5 text-sm font-medium rounded-md text-text-light dark:text-text-dark bg-gray-100 dark:bg-gray-700 hover:bg-gray-200 dark:hover:bg-gray-600 transition-colors"
//                         title="Start a new chat session"
//                     >
//                         <MessageSquare size={16} /> New Chat
//                     </button>
//                     <button
//                         onClick={onHistoryClick}
//                         className="flex items-center gap-1.5 px-3 py-1.5 text-sm font-medium rounded-md text-text-light dark:text-text-dark bg-gray-100 dark:bg-gray-700 hover:bg-gray-200 dark:hover:bg-gray-600 transition-colors"
//                         title="View chat history (Coming Soon)"
//                     >
//                         <History size={16} /> History
//                     </button>
//                     <button
//                         onClick={() => setIsLLMModalOpen(true)}
//                         className="flex items-center gap-1.5 px-3 py-1.5 text-sm font-medium rounded-md text-text-light dark:text-text-dark bg-gray-100 dark:bg-gray-700 hover:bg-gray-200 dark:hover:bg-gray-600 transition-colors"
//                         title={`Switch LLM (Current: ${selectedLLM.toUpperCase()})`}
//                     >
//                         <Cpu size={16} /> {selectedLLM.toUpperCase()}
//                     </button>
//                 </div>

//                 {/* Right Side: Theme, User, Logout */}
//                 <div className="flex items-center gap-2 sm:gap-3">
//                     {getStatusIndicator()}
//                     <ThemeToggle />
//                     <div className="relative group">
//                         <button className="p-1.5 bg-primary-light dark:bg-primary-dark text-white rounded-full focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-surface-light dark:focus:ring-offset-surface-dark focus:ring-primary">
//                             <User size={20} />
//                         </button>
//                         <div className="absolute right-0 mt-2 w-48 bg-surface-light dark:bg-surface-dark rounded-md shadow-lg py-1 opacity-0 group-hover:opacity-100 focus-within:opacity-100 transition-opacity duration-150 ease-in-out transform scale-95 group-hover:scale-100 focus-within:scale-100 origin-top-right invisible group-hover:visible focus-within:visible">
//                             <div className="px-4 py-2 text-sm text-text-light dark:text-text-dark border-b border-gray-200 dark:border-gray-600">
//                                 Signed in as <br/><strong>{user?.username || 'User'}</strong>
//                             </div>
//                             <button
//                                 onClick={() => { /* TODO: User Profile/Settings Modal */ toast.info("Profile settings coming soon!"); }}
//                                 className="w-full text-left px-4 py-2 text-sm text-text-light dark:text-text-dark hover:bg-gray-100 dark:hover:bg-gray-700 flex items-center gap-2"
//                             >
//                                 <Settings size={16} /> Profile
//                             </button>
//                             <button
//                                 onClick={logout}
//                                 className="w-full text-left px-4 py-2 text-sm text-red-600 dark:text-red-400 hover:bg-red-50 dark:hover:bg-red-900 flex items-center gap-2"
//                             >
//                                 <LogOut size={16} /> Logout
//                             </button>
//                         </div>
//                     </div>
//                      <button 
//                         onClick={() => setIsRightPanelOpen(prev => !prev)} 
//                         className="p-2 rounded-md hover:bg-gray-200 dark:hover:bg-gray-700 lg:hidden"
//                         title={isRightPanelOpen ? "Close Analyzer Panel" : "Open Analyzer Panel"} 
//                         aria-label="Toggle Analyzer Panel"
//                     >
//                         <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d={isRightPanelOpen ? "M6 18L18 6M6 6l12 12" : "M4 6h16M4 12h7m-7 6h16"}></path></svg>
//                     </button>
//                 </div>
//             </nav>
//             <LLMSelectionModal 
//                 isOpen={isLLMModalOpen} 
//                 onClose={() => setIsLLMModalOpen(false)} 
//                 currentLLM={selectedLLM}
//                 onSelectLLM={(llm) => {
//                     switchLLM(llm);
//                     setIsLLMModalOpen(false);
//                 }}
//             />
//         </>
//     );
// }
// export default TopNav;

// import React, { useState } from 'react';
// import { useAuth } from '../../hooks/useAuth';
// import { useAppState } from '../../contexts/AppStateContext';
// import ThemeToggle from '../common/ThemeToggle';
// import LLMSelectionModal from './LLMSelectionModal';
// import { 
//     LogOut, User, MessageSquare, History as HistoryIcon, Settings, Cpu, Zap, ServerCrash, Server, 
//     PanelLeftClose, PanelRightClose, PanelLeftOpen, PanelRightOpen, Menu // Lucide icons
// } from 'lucide-react';
// import toast from 'react-hot-toast'; // For placeholder actions

// function TopNav({ onNewChat, onHistoryClick, orchestratorStatus }) {
//     const { user, logout } = useAuth();
//     const { 
//         selectedLLM, switchLLM, 
//         isLeftPanelOpen, setIsLeftPanelOpen,
//         isRightPanelOpen, setIsRightPanelOpen
//     } = useAppState();
    
//     const [isLLMModalOpen, setIsLLMModalOpen] = useState(false);
    
//     const getStatusIndicator = () => {
//         if (!orchestratorStatus) return <div title="Status unavailable" className="w-4 h-4 bg-gray-400 rounded-full"></div>;
//         if (orchestratorStatus.status === "ok") {
//             return <Zap size={18} className="text-green-400 animate-pulse" title="Backend Online" />;
//         } else if (orchestratorStatus.status === "loading") {
//             return <div className="animate-spin rounded-full h-4 w-4 border-t-2 border-b-2 border-yellow-400" title="Connecting..."></div>;
//         } else {
//             return <ServerCrash size={18} className="text-red-400" title={`Backend Offline: ${orchestratorStatus.message}`} />;
//         }
//     };

//     return (
//         <>
//             <nav className="fixed top-0 left-0 right-0 z-40 bg-surface-light dark:bg-surface-dark border-b border-gray-200 dark:border-gray-700 shadow-sm h-16 flex items-center justify-between px-2 sm:px-4">
//                 {/* Left Side: Panel Toggle & Branding */}
//                 <div className="flex items-center gap-2">
//                     <button 
//                         onClick={() => setIsLeftPanelOpen(prev => !prev)} 
//                         className="p-2 rounded-md text-text-muted-light dark:text-text-muted-dark hover:bg-gray-200 dark:hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-primary"
//                         title={isLeftPanelOpen ? "Hide Assistant Panel" : "Show Assistant Panel"} 
//                         aria-label="Toggle Assistant Panel"
//                     >
//                         {isLeftPanelOpen ? <PanelLeftClose size={20} /> : <PanelLeftOpen size={20} />}
//                     </button>
//                     <a href="/" className="flex items-center gap-1.5 sm:gap-2 text-lg sm:text-xl font-semibold text-text-light dark:text-text-dark">
//                         <Server size={24} className="text-primary dark:text-primary-light" />
//                         <span className="hidden sm:inline">AI Tutor</span>
//                     </a>
//                 </div>

//                 {/* Center Controls - More adaptive */}
//                 <div className="flex-1 flex justify-center px-2">
//                     <div className="flex items-center gap-1 sm:gap-2">
//                         <button
//                             onClick={onNewChat}
//                             className="flex items-center gap-1 px-2 py-1.5 text-xs sm:text-sm font-medium rounded-md text-text-light dark:text-text-dark bg-gray-100 dark:bg-gray-700 hover:bg-gray-200 dark:hover:bg-gray-600 transition-colors"
//                             title="Start a new chat session"
//                         >
//                             <MessageSquare size={14} /> <span className="hidden sm:inline">New Chat</span>
//                         </button>
//                         <button
//                             onClick={onHistoryClick}
//                             className="flex items-center gap-1 px-2 py-1.5 text-xs sm:text-sm font-medium rounded-md text-text-light dark:text-text-dark bg-gray-100 dark:bg-gray-700 hover:bg-gray-200 dark:hover:bg-gray-600 transition-colors"
//                             title="View chat history (Coming Soon)"
//                         >
//                             <HistoryIcon size={14} /> <span className="hidden sm:inline">History</span>
//                         </button>
//                         <button
//                             onClick={() => setIsLLMModalOpen(true)}
//                             className="flex items-center gap-1 px-2 py-1.5 text-xs sm:text-sm font-medium rounded-md text-text-light dark:text-text-dark bg-gray-100 dark:bg-gray-700 hover:bg-gray-200 dark:hover:bg-gray-600 transition-colors"
//                             title={`Switch LLM (Current: ${selectedLLM.toUpperCase()})`}
//                         >
//                             <Cpu size={14} /> <span className="hidden xs:inline">{selectedLLM.toUpperCase()}</span>
//                         </button>
//                     </div>
//                 </div>


//                 {/* Right Side: Status, Theme, User, Panel Toggle */}
//                 <div className="flex items-center gap-1.5 sm:gap-2">
//                     {getStatusIndicator()}
//                     <ThemeToggle />
//                     <div className="relative group">
//                         <button className="p-1.5 bg-primary-light dark:bg-primary-dark text-white rounded-full focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-surface-light dark:focus:ring-offset-surface-dark focus:ring-primary">
//                             <User size={18} />
//                         </button>
//                         <div className="absolute right-0 mt-2 w-48 bg-surface-light dark:bg-surface-dark rounded-md shadow-lg py-1 opacity-0 group-hover:opacity-100 focus-within:opacity-100 transition-opacity duration-150 ease-in-out transform scale-95 group-hover:scale-100 focus-within:scale-100 origin-top-right invisible group-hover:visible focus-within:visible z-50">
//                             <div className="px-4 py-2 text-sm text-text-light dark:text-text-dark border-b border-gray-200 dark:border-gray-600">
//                                 Signed in as <br/><strong>{user?.username || 'User'}</strong>
//                             </div>
//                             <button
//                                 onClick={() => toast.info("Profile settings coming soon!")}
//                                 className="w-full text-left px-4 py-2 text-sm text-text-light dark:text-text-dark hover:bg-gray-100 dark:hover:bg-gray-700 flex items-center gap-2"
//                             >
//                                 <Settings size={16} /> Profile
//                             </button>
//                             <button
//                                 onClick={logout}
//                                 className="w-full text-left px-4 py-2 text-sm text-red-600 dark:text-red-400 hover:bg-red-50 dark:hover:bg-red-900 flex items-center gap-2"
//                             >
//                                 <LogOut size={16} /> Logout
//                             </button>
//                         </div>
//                     </div>
//                     <button 
//                         onClick={() => setIsRightPanelOpen(prev => !prev)} 
//                         className="p-2 rounded-md text-text-muted-light dark:text-text-muted-dark hover:bg-gray-200 dark:hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-primary"
//                         title={isRightPanelOpen ? "Hide Analyzer Panel" : "Show Analyzer Panel"} 
//                         aria-label="Toggle Analyzer Panel"
//                     >
//                         {isRightPanelOpen ? <PanelRightClose size={20} /> : <PanelRightOpen size={20} />}
//                     </button>
//                 </div>
//             </nav>
//             <LLMSelectionModal 
//                 isOpen={isLLMModalOpen} 
//                 onClose={() => setIsLLMModalOpen(false)} 
//                 currentLLM={selectedLLM}
//                 onSelectLLM={(llm) => { // This callback is passed to the modal
//                     switchLLM(llm); // Update global state via AppStateContext
//                     // The modal will also call its own API to save this preference
//                     setIsLLMModalOpen(false);
//                 }}
//             />
//         </>
//     );
// }
// export default TopNav;












// frontend/src/components/layout/TopNav.jsx
import React, { useState } from 'react';
import { useAuth } from '../../hooks/useAuth';
import { useAppState } from '../../contexts/AppStateContext';
import ThemeToggle from '../common/ThemeToggle.jsx';
import LLMSelectionModal from './LLMSelectionModal.jsx';
import { 
    LogOut, User, MessageSquare, History as HistoryIcon, Settings, Cpu, Zap, ServerCrash, Server 
} from 'lucide-react';
import toast from 'react-hot-toast';

function TopNav({ onNewChat, onHistoryClick, orchestratorStatus }) {
    const { user, logout } = useAuth();
    const { selectedLLM, switchLLM } = useAppState(); // Panels are NOT controlled from here
    const [isLLMModalOpen, setIsLLMModalOpen] = useState(false);
    
    const getStatusIndicator = () => { /* ... as provided before ... */ };

    return (
        <>
            <nav className="fixed top-0 left-0 right-0 z-40 bg-surface-light dark:bg-surface-dark border-b border-border-light dark:border-border-dark shadow-sm h-16 flex items-center justify-between px-2 sm:px-4">
                {/* Left Side: Branding (No panel toggle here) */}
                <div className="flex items-center gap-2">
                    <a href="/" className="flex items-center gap-1.5 sm:gap-2 text-lg sm:text-xl font-semibold text-text-light dark:text-text-dark">
                        <Server size={24} className="text-primary dark:text-primary-light" />
                        <span className="hidden sm:inline">AI Tutor</span>
                    </a>
                </div>

                {/* Center Controls */}
                <div className="flex-1 flex justify-center px-2">
                    <div className="flex items-center gap-1 sm:gap-2">
                        {/* New Chat, History, LLM buttons as before */}
                         <button
                            onClick={onNewChat}
                            className="flex items-center gap-1 px-2 py-1.5 text-xs sm:text-sm font-medium rounded-md text-text-light dark:text-text-dark bg-gray-100 dark:bg-gray-700 hover:bg-gray-200 dark:hover:bg-gray-600 transition-colors"
                            title="Start a new chat session"
                        >
                            <MessageSquare size={14} /> <span className="hidden sm:inline">New Chat</span>
                        </button>
                        <button
                            onClick={onHistoryClick}
                            className="flex items-center gap-1 px-2 py-1.5 text-xs sm:text-sm font-medium rounded-md text-text-light dark:text-text-dark bg-gray-100 dark:bg-gray-700 hover:bg-gray-200 dark:hover:bg-gray-600 transition-colors"
                            title="View chat history"
                        >
                            <HistoryIcon size={14} /> <span className="hidden sm:inline">History</span>
                        </button>
                        <button
                            onClick={() => setIsLLMModalOpen(true)}
                            className="flex items-center gap-1 px-2 py-1.5 text-xs sm:text-sm font-medium rounded-md text-text-light dark:text-text-dark bg-gray-100 dark:bg-gray-700 hover:bg-gray-200 dark:hover:bg-gray-600 transition-colors"
                            title={`Switch LLM (Current: ${selectedLLM.toUpperCase()})`}
                        >
                            <Cpu size={14} /> <span className="hidden xs:inline">{selectedLLM.toUpperCase()}</span>
                        </button>
                    </div>
                </div>

                {/* Right Side: Status, Theme, User (No panel toggle here) */}
                <div className="flex items-center gap-1.5 sm:gap-2">
                    {getStatusIndicator()}
                    <ThemeToggle />
                    <div className="relative group">
                        <button className="p-1.5 bg-primary-light dark:bg-primary-dark text-white rounded-full focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-surface-light dark:focus:ring-offset-surface-dark focus:ring-primary">
                            <User size={18} />
                        </button>
                        {/* User Dropdown Menu */}
                        <div className="absolute right-0 mt-2 w-48 bg-surface-light dark:bg-surface-dark rounded-md shadow-lg py-1 opacity-0 group-hover:opacity-100 focus-within:opacity-100 transition-opacity duration-150 ease-in-out transform scale-95 group-hover:scale-100 focus-within:scale-100 origin-top-right invisible group-hover:visible focus-within:visible z-50">
                            <div className="px-4 py-2 text-sm text-text-light dark:text-text-dark border-b border-border-light dark:border-border-dark">
                                Signed in as <br/><strong>{user?.username || 'User'}</strong>
                            </div>
                            <button
                                onClick={() => toast.info("Profile settings coming soon!")}
                                className="w-full text-left px-4 py-2 text-sm text-text-light dark:text-text-dark hover:bg-gray-100 dark:hover:bg-gray-700 flex items-center gap-2"
                            >
                                <Settings size={16} /> Profile
                            </button>
                            <button
                                onClick={logout}
                                className="w-full text-left px-4 py-2 text-sm text-red-600 dark:text-red-400 hover:bg-red-50 dark:hover:bg-red-900 flex items-center gap-2"
                            >
                                <LogOut size={16} /> Logout
                            </button>
                        </div>
                    </div>
                </div>
            </nav>
            <LLMSelectionModal 
                isOpen={isLLMModalOpen} 
                onClose={() => setIsLLMModalOpen(false)} 
                currentLLM={selectedLLM}
                onSelectLLM={(llm) => {
                    switchLLM(llm);
                    setIsLLMModalOpen(false);
                }}
            />
        </>
    );
}
export default TopNav;



```

`src/contexts/AppStateContext.jsx`

```javascript
// import React, { createContext, useState, useContext } from 'react';

// export const AppStateContext = createContext();

// export const useAppState = () => useContext(AppStateContext);

// export const AppStateProvider = ({ children }) => {
//     const [theme, setTheme] = useState(localStorage.getItem('theme') || 'dark'); // 'light' or 'dark'
//     const [selectedLLM, setSelectedLLM] = useState(localStorage.getItem('selectedLLM') || 'ollama'); // 'ollama' or 'gemini'
//     const [isLeftPanelOpen, setIsLeftPanelOpen] = useState(true);
//     const [isRightPanelOpen, setIsRightPanelOpen] = useState(false); // Initially closed
//     const [currentSessionId, setCurrentSessionId] = useState(localStorage.getItem('aiTutorSessionId') || null);

//     const toggleTheme = () => {
//         const newTheme = theme === 'light' ? 'dark' : 'light';
//         setTheme(newTheme);
//         localStorage.setItem('theme', newTheme);
//         document.documentElement.classList.toggle('dark', newTheme === 'dark');
//     };
    
//     const switchLLM = (llm) => {
//         setSelectedLLM(llm);
//         localStorage.setItem('selectedLLM', llm);
//         // Potentially trigger API key update modal if switching to Gemini and key not set
//     };

//     const setSessionId = (sessionId) => {
//         setCurrentSessionId(sessionId);
//         if (sessionId) {
//             localStorage.setItem('aiTutorSessionId', sessionId);
//         } else {
//             localStorage.removeItem('aiTutorSessionId');
//         }
//     };


//     return (
//         <AppStateContext.Provider value={{
//             theme, toggleTheme,
//             selectedLLM, switchLLM,
//             isLeftPanelOpen, setIsLeftPanelOpen,
//             isRightPanelOpen, setIsRightPanelOpen,
//             currentSessionId, setSessionId
//         }}>
//             {children}
//         </AppStateContext.Provider>
//     );
// };
// ... other imports ...
// const DEV_MODE_BYPASS_AUTH = true; // Match the value in AuthContext for consistency in dev setup

// export const AppStateProvider = ({ children }) => {
//     // ... other states ...
//     const [currentSessionId, setCurrentSessionId] = useState(
//         DEV_MODE_BYPASS_AUTH 
//         ? 'dev-session-123' 
//         : localStorage.getItem('aiTutorSessionId') || null
//     );

//     // ... rest of the AppStateProvider ...

//     const setSessionId = (sessionId) => {
//         setCurrentSessionId(sessionId);
//         if (DEV_MODE_BYPASS_AUTH && !sessionId) { // Prevent clearing dev session on accidental null set
//             console.log("DEV_MODE: Preventing clearing of dev session ID.");
//             if (!currentSessionId) setCurrentSessionId('dev-session-123'); // Reset if it somehow got cleared
//             return;
//         }
//         if (sessionId) {
//             localStorage.setItem('aiTutorSessionId', sessionId);
//         } else {
//             localStorage.removeItem('aiTutorSessionId');
//         }
//     };

//     return (
//         <AppStateContext.Provider value={{
//             // ... other values ...
//             currentSessionId, setSessionId 
//         }}>
//             {children}
//         </AppStateContext.Provider>
//     );
// };
// frontend/src/contexts/AppStateContext.jsx

// import React, { createContext, useState, useContext, useEffect } from 'react';

// export const AppStateContext = createContext(null); // Initialize with null

// export const useAppState = () => { // Custom hook to use the AppStateContext
//     const context = useContext(AppStateContext);
//     if (context === undefined || context === null) { // Check if context is undefined or null
//         throw new Error('useAppState must be used within an AppStateProvider');
//     }
//     return context;
// };

// const DEV_MODE_BYPASS_AUTH = true; // Ensure this matches other dev flags if used for initial state

// export const AppStateProvider = ({ children }) => {
//     const [theme, setThemeState] = useState(() => {
//         const storedTheme = localStorage.getItem('theme');
//         // Ensure theme is applied on initial load if not already on html tag
//         if (storedTheme === 'dark') document.documentElement.classList.add('dark');
//         else document.documentElement.classList.remove('dark');
//         return storedTheme || 'dark';
//     });
//     const [selectedLLM, setSelectedLLM] = useState(localStorage.getItem('selectedLLM') || 'ollama');
//     const [isLeftPanelOpen, setIsLeftPanelOpen] = useState(true);
//     const [isRightPanelOpen, setIsRightPanelOpen] = useState(false);
//     const [currentSessionId, setCurrentSessionIdState] = useState(
//         DEV_MODE_BYPASS_AUTH
//         ? 'dev-session-appstate-123' // Consistent dev session ID
//         : localStorage.getItem('aiTutorSessionId') || null
//     );
//     // State for the selected document for analysis
//     const [selectedDocumentForAnalysis, setSelectedDocumentForAnalysis] = useState(null);


//     const toggleTheme = () => {
//         setThemeState(prevTheme => {
//             const newTheme = prevTheme === 'light' ? 'dark' : 'light';
//             localStorage.setItem('theme', newTheme);
//             document.documentElement.classList.toggle('dark', newTheme === 'dark');
//             // For Tailwind, class on <html> is usually enough.
//             // If you have body-specific theme styles:
//             // document.body.classList.remove(prevTheme);
//             // document.body.classList.add(newTheme);
//             return newTheme;
//         });
//     };
    
//     const switchLLM = (llm) => {
//         setSelectedLLM(llm);
//         localStorage.setItem('selectedLLM', llm);
//     };

//     const setSessionId = (sessionId) => {
//         setCurrentSessionIdState(sessionId);
//         if (DEV_MODE_BYPASS_AUTH && !sessionId && currentSessionId) {
//              console.warn("DEV_MODE: Attempted to clear dev session ID. Retaining current dev session.");
//              if(!currentSessionIdState) setCurrentSessionIdState('dev-session-appstate-123'); // Ensure it has a value
//              return;
//         }
//         if (sessionId) {
//             localStorage.setItem('aiTutorSessionId', sessionId);
//         } else {
//             localStorage.removeItem('aiTutorSessionId');
//         }
//     };

//     const selectDocumentForAnalysis = (documentFile) => { // documentFile could be { originalName, serverFilename }
//         setSelectedDocumentForAnalysis(documentFile);
//     };

//     // Apply theme to HTML element on initial load and when theme changes
//      useEffect(() => {
//         if (theme === 'dark') {
//             document.documentElement.classList.add('dark');
//         } else {
//             document.documentElement.classList.remove('dark');
//         }
//     }, [theme]);


//     return (
//         <AppStateContext.Provider value={{
//             theme, toggleTheme,
//             selectedLLM, switchLLM,
//             isLeftPanelOpen, setIsLeftPanelOpen,
//             isRightPanelOpen, setIsRightPanelOpen,
//             currentSessionId, setSessionId, // Use the wrapped setter
//             selectedDocumentForAnalysis, selectDocumentForAnalysis
//         }}>
//             {children}
//         </AppStateContext.Provider>
//     );
// };




// // frontend/src/contexts/AppStateContext.jsx
// import React, { createContext, useState, useContext, useEffect } from 'react';

// export const AppStateContext = createContext(null);

// export const useAppState = () => {
//     const context = useContext(AppStateContext);
//     if (!context) { // Simplified check, assuming context is not intentionally undefined after init
//         throw new Error('useAppState must be used within an AppStateProvider');
//     }
//     return context;
// };

// // This flag is used to set an initial dev session ID if needed when Auth is also bypassed.
// // For normal operation where AuthModal is shown, this particular flag's effect on session ID is less critical
// // as the session ID will be set after login/devLogin.
// const DEV_MODE_CONTEXT_INIT = true; 

// export const AppStateProvider = ({ children }) => {
//     const [theme, setThemeState] = useState(() => {
//         const storedTheme = localStorage.getItem('theme') || 'dark';
//         // Apply theme on initial load (client-side only)
//         if (typeof window !== 'undefined') {
//              if (storedTheme === 'dark') {
//                 document.documentElement.classList.add('dark');
//             } else {
//                 document.documentElement.classList.remove('dark');
//             }
//         }
//         return storedTheme;
//     });

//     const [selectedLLM, setSelectedLLM] = useState(localStorage.getItem('selectedLLM') || 'ollama');
//     const [isLeftPanelOpen, setIsLeftPanelOpen] = useState(true);
//     const [isRightPanelOpen, setIsRightPanelOpen] = useState(true); // Default to true as per screenshot for desktop
    
//     const [currentSessionId, setCurrentSessionIdState] = useState(() => {
//         if (DEV_MODE_CONTEXT_INIT && !localStorage.getItem('aiTutorSessionId')) {
//             // Only set a dev session if no real session ID is found AND we are in a dev context init mode
//             return 'dev-session-appstate-default';
//         }
//         return localStorage.getItem('aiTutorSessionId') || null;
//     });

//     const [systemPrompt, setSystemPromptState] = useState(
//         localStorage.getItem('aiTutorSystemPrompt') || 
//         "You are a helpful AI engineering tutor." // Default
//     );
//     const [selectedDocumentForAnalysis, setSelectedDocumentForAnalysisState] = useState(null); // Stores { originalName, serverFilename }

//     const toggleTheme = () => {
//         setThemeState(prevTheme => {
//             const newTheme = prevTheme === 'light' ? 'dark' : 'light';
//             localStorage.setItem('theme', newTheme);
//             // document.documentElement.classList.toggle('dark', newTheme === 'dark'); // useEffect handles this
//             return newTheme;
//         });
//     };
    
//     const switchLLM = (llm) => {
//         setSelectedLLM(llm);
//         localStorage.setItem('selectedLLM', llm);
//     };

//     const setSessionId = (sessionId) => {
//         setCurrentSessionIdState(sessionId);
//         if (sessionId) {
//             localStorage.setItem('aiTutorSessionId', sessionId);
//         } else {
//             // Only remove if not in a strict dev initial session mode, or handle carefully
//             if (DEV_MODE_CONTEXT_INIT && sessionId === null && currentSessionId && currentSessionId.startsWith('dev-session')) {
//                 console.warn("AppStateContext DEV_MODE: Attempt to clear dev session ID. Retaining.");
//                 return; // Prevent clearing if it's a dev session and we want to keep it
//             }
//             localStorage.removeItem('aiTutorSessionId');
//         }
//     };

//     const setSystemPrompt = (promptText) => {
//         setSystemPromptState(promptText);
//         localStorage.setItem('aiTutorSystemPrompt', promptText);
//     };

//     const selectDocumentForAnalysis = (documentFile) => { // documentFile is { originalName, serverFilename } or null
//         setSelectedDocumentForAnalysisState(documentFile);
//     };

//     // Effect to apply theme class to HTML element when theme state changes
//     useEffect(() => {
//         if (typeof window !== 'undefined') {
//             document.documentElement.classList.remove('light', 'dark'); // Clear previous
//             document.documentElement.classList.add(theme); // Add current
//         }
//     }, [theme]);

//     return (
//         <AppStateContext.Provider value={{
//             theme, toggleTheme,
//             selectedLLM, switchLLM,
//             isLeftPanelOpen, setIsLeftPanelOpen,
//             isRightPanelOpen, setIsRightPanelOpen,
//             currentSessionId, setSessionId, // Pass the state and its setter
//             systemPrompt, setSystemPrompt,   // Pass systemPrompt and its setter
//             selectedDocumentForAnalysis, selectDocumentForAnalysis // Pass selected doc and its setter
//         }}>
//             {children}
//         </AppStateContext.Provider>
//     );
// };




// // frontend/src/contexts/AppStateContext.jsx
// import React, { createContext, useState, useContext, useEffect } from 'react';

// export const AppStateContext = createContext(null);

// export const useAppState = () => {
//     const context = useContext(AppStateContext);
//     if (!context) throw new Error('useAppState must be used within an AppStateProvider');
//     return context;
// };

// // Default system prompt if nothing is stored
// const defaultSystemPromptText = "You are a helpful AI engineering tutor.";

// export const AppStateProvider = ({ children }) => {
//     const [theme, setThemeState] = useState(() => localStorage.getItem('theme') || 'dark');
//     const [selectedLLM, setSelectedLLM] = useState(localStorage.getItem('selectedLLM') || 'ollama');
//     const [isLeftPanelOpen, setIsLeftPanelOpen] = useState(true);
//     const [isRightPanelOpen, setIsRightPanelOpen] = useState(true); 
//     const [currentSessionId, setCurrentSessionIdState] = useState(
//         localStorage.getItem('aiTutorSessionId') || null
//     );
//     // --- New state for system prompt ---
//     const [systemPrompt, setSystemPromptState] = useState(
//         localStorage.getItem('aiTutorSystemPrompt') || defaultSystemPromptText
//     );
//     // --- End new state ---
    
//     const [selectedDocumentForAnalysis, setSelectedDocumentForAnalysisState] = useState(null);

//     const toggleTheme = () => {
//         setThemeState(prevTheme => {
//             const newTheme = prevTheme === 'light' ? 'dark' : 'light';
//             localStorage.setItem('theme', newTheme);
//             return newTheme;
//         });
//     };
    
//     const switchLLM = (llm) => {
//         setSelectedLLM(llm);
//         localStorage.setItem('selectedLLM', llm);
//     };

//     const setSessionId = (sessionId) => {
//         setCurrentSessionIdState(sessionId);
//         if (sessionId) localStorage.setItem('aiTutorSessionId', sessionId);
//         else localStorage.removeItem('aiTutorSessionId');
//     };

//     // --- New setter for system prompt ---
//     const setSystemPrompt = (promptText) => {
//         setSystemPromptState(promptText);
//         if (promptText) {
//             localStorage.setItem('aiTutorSystemPrompt', promptText);
//         } else {
//             localStorage.removeItem('aiTutorSystemPrompt'); // Or set to default
//             setSystemPromptState(defaultSystemPromptText); // Reset to default if cleared
//         }
//     };
//     // --- End new setter ---

//     const selectDocumentForAnalysis = (documentFile) => {
//         setSelectedDocumentForAnalysisState(documentFile);
//     };

//     useEffect(() => {
//         document.documentElement.classList.remove('light', 'dark');
//         document.documentElement.classList.add(theme);
//     }, [theme]);

//     return (
//         <AppStateContext.Provider value={{
//             theme, toggleTheme,
//             selectedLLM, switchLLM,
//             isLeftPanelOpen, setIsLeftPanelOpen,
//             isRightPanelOpen, setIsRightPanelOpen,
//             currentSessionId, setSessionId,
//             // --- Provide systemPrompt and setter ---
//             systemPrompt, setSystemPrompt, 
//             // --- End provide ---
//             selectedDocumentForAnalysis, selectDocumentForAnalysis
//         }}>
//             {children}
//         </AppStateContext.Provider>
//     );
// };




// frontend/src/contexts/AppStateContext.jsx
import React, { createContext, useState, useContext, useEffect } from 'react';

// 1. Create the Context (named export)
export const AppStateContext = createContext(null);

// 2. Create and Export the Custom Hook (named export)
export const useAppState = () => {
    const context = useContext(AppStateContext);
    if (context === undefined || context === null) {
        throw new Error('useAppState must be used within an AppStateProvider. Make sure your component is wrapped by AppStateProvider in main.jsx or App.jsx.');
    }
    return context;
};

// This can be a local constant if only used here for initial state logic
const DEV_MODE_APPSTATE_INIT_SESSION = true; 

// 3. Create and Export the Provider Component (named export)
export const AppStateProvider = ({ children }) => {
    const [theme, setThemeState] = useState(() => {
        const storedTheme = localStorage.getItem('theme') || 'dark';
        if (typeof window !== 'undefined') {
             if (storedTheme === 'dark') {
                document.documentElement.classList.add('dark');
            } else {
                document.documentElement.classList.remove('dark');
            }
        }
        return storedTheme;
    });

    const [selectedLLM, setSelectedLLM] = useState(localStorage.getItem('selectedLLM') || 'ollama');
    const [isLeftPanelOpen, setIsLeftPanelOpen] = useState(true);
    const [isRightPanelOpen, setIsRightPanelOpen] = useState(true); 
    
    const [currentSessionId, setCurrentSessionIdState] = useState(() => {
        const storedSession = localStorage.getItem('aiTutorSessionId');
        if (storedSession) return storedSession;
        if (DEV_MODE_APPSTATE_INIT_SESSION) return 'dev-initial-session-appstate';
        return null;
    });
    
    const [systemPrompt, setSystemPromptState] = useState(
        localStorage.getItem('aiTutorSystemPrompt') || 
        "You are a helpful AI engineering tutor."
    );
    
    const [selectedDocumentForAnalysis, setSelectedDocumentForAnalysisState] = useState(null);

    const toggleTheme = () => {
        setThemeState(prevTheme => {
            const newTheme = prevTheme === 'light' ? 'dark' : 'light';
            localStorage.setItem('theme', newTheme);
            return newTheme;
        });
    };
    
    const switchLLM = (llm) => {
        setSelectedLLM(llm);
        localStorage.setItem('selectedLLM', llm);
    };

    const setSessionId = (sessionId) => {
        setCurrentSessionIdState(sessionId);
        if (sessionId) {
            localStorage.setItem('aiTutorSessionId', sessionId);
        } else {
            // Conditional logic for dev mode if needed, otherwise just remove
            if (DEV_MODE_APPSTATE_INIT_SESSION && currentSessionId && currentSessionId.startsWith('dev-')) {
                console.warn("AppStateContext DEV_MODE: Attempt to clear dev session ID. Retaining.");
                return; 
            }
            localStorage.removeItem('aiTutorSessionId');
        }
    };

    const setSystemPrompt = (promptText) => {
        setSystemPromptState(promptText);
        localStorage.setItem('aiTutorSystemPrompt', promptText);
    };

    const selectDocumentForAnalysis = (documentFile) => {
        setSelectedDocumentForAnalysisState(documentFile);
    };

    useEffect(() => {
        if (typeof window !== 'undefined') {
            document.documentElement.classList.remove('light', 'dark');
            document.documentElement.classList.add(theme);
        }
    }, [theme]);

    const contextValue = {
        theme, toggleTheme,
        selectedLLM, switchLLM,
        isLeftPanelOpen, setIsLeftPanelOpen,
        isRightPanelOpen, setIsRightPanelOpen,
        currentSessionId, setSessionId,
        systemPrompt, setSystemPrompt,
        selectedDocumentForAnalysis, selectDocumentForAnalysis
    };

    return (
        <AppStateContext.Provider value={contextValue}>
            {children}
        </AppStateContext.Provider>
    );
};

// NO DEFAULT EXPORT if all are named exports used elsewhere
// If you had a default export, it would be like:
// export default SomePrimaryComponentOrObject;
```

`src/contexts/AuthContext.jsx`

```javascript
import React, { createContext, useState, useEffect, useCallback } from 'react';
import api from '../services/api';
import { jwtDecode } from 'jwt-decode'; // npm install jwt-decode

export const AuthContext = createContext(null);

export const AuthProvider = ({ children }) => {
    const [token, setToken] = useState(localStorage.getItem('authToken'));
    const [user, setUser] = useState(null); // { id, username, llmProvider, apiKey }
    const [loading, setLoading] = useState(true); // Initial auth check

    const parseToken = useCallback((tok) => {
        if (!tok) return null;
        try {
            const decoded = jwtDecode(tok); // Ensure your JWT has these fields
            return { id: decoded.id, username: decoded.username }; // Add other fields if present
        } catch (e) {
            console.error("Failed to decode token:", e);
            localStorage.removeItem('authToken');
            return null;
        }
    }, []);

    useEffect(() => {
        const storedToken = localStorage.getItem('authToken');
        if (storedToken) {
            const decodedUser = parseToken(storedToken);
            if (decodedUser) {
                setUser(decodedUser);
                setToken(storedToken);
                api.defaults.headers.common['Authorization'] = `Bearer ${storedToken}`; // For axios global config
            } else {
                // Invalid token found
                localStorage.removeItem('authToken');
            }
        }
        setLoading(false);
    }, [parseToken]);

    const login = async (credentials) => {
        try {
            const data = await api.login(credentials); // API should return { token, userDetails, sessionId }
            localStorage.setItem('authToken', data.token);
            const decodedUser = parseToken(data.token);
            setUser(decodedUser);
            setToken(data.token);
            api.defaults.headers.common['Authorization'] = `Bearer ${data.token}`;
            return data; // Pass along sessionId, etc.
        } catch (error) {
            console.error("Login failed:", error);
            throw error;
        }
    };
    
    const signup = async (signupData) => { // signupData includes username, password, llmProvider, apiKey (optional)
        try {
            // The actual API key storage should be handled securely by the backend.
            // Frontend might only send it during initial signup or LLM config update.
            // The backend then encrypts and stores it, never sending it back.
            const data = await api.signup(signupData); // API handles user creation
             // After signup, typically auto-login or prompt to login
            // For now, let's assume signup returns token like login for immediate use
            if(data.token) {
                localStorage.setItem('authToken', data.token);
                const decodedUser = parseToken(data.token);
                setUser(decodedUser);
                setToken(data.token);
                api.defaults.headers.common['Authorization'] = `Bearer ${data.token}`;
            }
            return data;
        } catch (error) {
            console.error("Signup failed:", error);
            throw error;
        }
    };

    const logout = () => {
        localStorage.removeItem('authToken');
        setUser(null);
        setToken(null);
        delete api.defaults.headers.common['Authorization'];
    };

    return (
        <AuthContext.Provider value={{ token, user, loading, login, signup, logout, setUser, setToken }}>
            {children}
        </AuthContext.Provider>
    );
};

import React, { createContext, useState, useEffect, useCallback } from 'react';
// import api from '../services/api'; // We'll mock API calls for now
// import { jwtDecode } from 'jwt-decode';

export const AuthContext = createContext(null);

const DEV_MODE_BYPASS_AUTH = true; // <--- SET THIS TO true FOR BYPASS

export const AuthProvider = ({ children }) => {
    const [token, setToken] = useState(DEV_MODE_BYPASS_AUTH ? 'fake-dev-token' : localStorage.getItem('authToken'));
    const [user, setUser] = useState(
        DEV_MODE_BYPASS_AUTH 
        ? { id: 'devUser123', username: 'DevUser' } 
        : null
    );
    const [loading, setLoading] = useState(false); // Set to false if bypassing initial auth check

    // Original parseToken and useEffect for real auth can be kept but won't run if DEV_MODE_BYPASS_AUTH is true
    const parseToken = useCallback((tok) => { /* ... original code ... */ }, []);
    useEffect(() => {
        if (DEV_MODE_BYPASS_AUTH) {
            setLoading(false); // Already set user and token
            return;
        }
        // ... original useEffect logic for real auth ...
        setLoading(false); // Ensure loading is set to false after check
    }, [parseToken]);


    const login = async (credentials) => {
        if (DEV_MODE_BYPASS_AUTH) {
            console.log("DEV_MODE: Bypassing real login.", credentials);
            const fakeUserData = { id: 'devUser123', username: credentials.username || 'DevUser' };
            setUser(fakeUserData);
            setToken('fake-dev-token');
            return { token: 'fake-dev-token', userDetails: fakeUserData, sessionId: 'dev-session-123' };
        }
        // ... original login logic using api.login ...
    };
    
    const signup = async (signupData) => {
         if (DEV_MODE_BYPASS_AUTH) {
            console.log("DEV_MODE: Bypassing real signup.", signupData);
            const fakeUserData = { id: 'devUserSignup123', username: signupData.username || 'NewDevUser' };
            setUser(fakeUserData);
            setToken('fake-dev-signup-token');
            // In dev mode, simulate setting the LLM from signup
            // This would normally be handled by AppStateContext or through API
            // const { switchLLM } = useAppState(); // Can't use hook here
            // if (signupData.llmProvider) { /* update global state somehow or ignore for now */ }
            return { token: 'fake-dev-signup-token', userDetails: fakeUserData, sessionId: 'dev-session-signup-123' };
        }
        // ... original signup logic using api.signup ...
    };

    const logout = () => {
        if (DEV_MODE_BYPASS_AUTH) {
            // To test the logout flow even in dev mode, you might want to clear the fake state
            // For now, let's keep it simple: to "logout" in dev, you'd set DEV_MODE_BYPASS_AUTH to false and refresh
            // or implement a dev-mode specific logout:
            // setUser(null);
            // setToken(null);
            // console.log("DEV_MODE: Simulated logout. Refresh or set DEV_MODE_BYPASS_AUTH=false to see AuthModal.");
            // Or, for a more realistic test of the logout flow:
            localStorage.removeItem('authToken'); // Still good to remove if it was set
            setUser(null);
            setToken(null);
            // No API call for logout in this simplified bypass
            return;
        }
        // ... original logout logic ...
    };

    return (
        <AuthContext.Provider value={{ token, user, loading, login, signup, logout, setUser, setToken }}>
            {children}
        </AuthContext.Provider>
    );
};


// import React, { createContext, useState, useEffect, useCallback } from 'react';
// import api from '../services/api'; // We'll still use the mock or real API
// import { jwtDecode } from 'jwt-decode';

// export const AuthContext = createContext(null);

// export const DEV_MODE_ALLOW_DEV_LOGIN = true; // New flag: Allows a special "Dev Login" button
// // const DEV_MODE_BYPASS_AUTH = false; // We are no longer fully bypassing, so this might be false or removed

// export const AuthProvider = ({ children }) => {
//     const [token, setToken] = useState(localStorage.getItem('authToken'));
//     const [user, setUser] = useState(null);
//     const [loading, setLoading] = useState(true);

//     const parseToken = useCallback((tok) => {
//         if (!tok) return null;
//         try {
//             const decoded = jwtDecode(tok);
//             return { id: decoded.id, username: decoded.username };
//         } catch (e) {
//             console.error("Failed to decode token:", e);
//             localStorage.removeItem('authToken');
//             return null;
//         }
//     }, []);

//     useEffect(() => {
//         const storedToken = localStorage.getItem('authToken');
//         if (storedToken) {
//             const decodedUser = parseToken(storedToken);
//             if (decodedUser) {
//                 setUser(decodedUser);
//                 setToken(storedToken);
//                 // If using axios global config for token:
//                 // apiClient.defaults.headers.common['Authorization'] = `Bearer ${storedToken}`;
//             }
//         }
//         setLoading(false);
//     }, [parseToken]);

//     const login = async (credentials) => {
//         // Real login logic (or mock if api.js is in mock mode)
//         try {
//             const data = await api.login(credentials); 
//             localStorage.setItem('authToken', data.token);
//             const decodedUser = parseToken(data.token);
//             setUser(decodedUser);
//             setToken(data.token);
//             // if (apiClient) apiClient.defaults.headers.common['Authorization'] = `Bearer ${data.token}`;
//             return data; 
//         } catch (error) {
//             console.error("Login failed:", error);
//             throw error;
//         }
//     };
    
//     const signup = async (signupData) => {
//         // Real signup logic (or mock)
//         try {
//             const data = await api.signup(signupData);
//             if(data.token) { // Assuming signup also returns a token for auto-login
//                 localStorage.setItem('authToken', data.token);
//                 const decodedUser = parseToken(data.token);
//                 setUser(decodedUser);
//                 setToken(data.token);
//                 // if (apiClient) apiClient.defaults.headers.common['Authorization'] = `Bearer ${data.token}`;
//             }
//             return data;
//         } catch (error) {
//             console.error("Signup failed:", error);
//             throw error;
//         }
//     };

//     const logout = () => {
//         localStorage.removeItem('authToken');
//         setUser(null);
//         setToken(null);
//         // if (apiClient) delete apiClient.defaults.headers.common['Authorization'];
//         // Also clear session from AppStateContext if needed, usually done in App.jsx's logout handler
//     };

//     // Special function for Dev Login button
//     const devLogin = () => {
//         if (DEV_MODE_ALLOW_DEV_LOGIN) {
//             const devToken = 'fake-dev-token-for-button';
//             const devUser = { id: 'devUserFromButton', username: 'DevButtonUser' };
//             localStorage.setItem('authToken', devToken);
//             setUser(devUser);
//             setToken(devToken);
//             // if (apiClient) apiClient.defaults.headers.common['Authorization'] = `Bearer ${devToken}`;
//             console.log("DEV_MODE: Logged in as DevButtonUser");
//             return { token: devToken, username: devUser.username, _id: devUser.id, sessionId: 'dev-session-from-button' };
//         }
//         return null;
//     };


//     return (
//         <AuthContext.Provider value={{ token, user, loading, login, signup, logout, devLogin, setUser, setToken, DEV_MODE_ALLOW_DEV_LOGIN }}>
//             {children}
//         </AuthContext.Provider>
//     );
// };




```

`src/hooks/useAuth.jsx`

```javascript
import { useContext } from 'react';
import { AuthContext } from '../contexts/AuthContext';

export const useAuth = () => {
    const context = useContext(AuthContext);
    if (!context) {
        throw new Error('useAuth must be used within an AuthProvider');
    }
    return context;
};
```

`src/hooks/useTheme.js`

```javascript
// import { useContext } from 'react';
// import { AppStateContext } from '../contexts/AppStateContext'; // Assuming theme is in AppStateContext

// export const useTheme = () => {
//     const context = useContext(AppStateContext);
//     if (!context) {
//         throw new Error('useTheme must be used within an AppStateProvider');
//     }
//     return { theme: context.theme, toggleTheme: context.toggleTheme };
// };


import { useContext } from 'react';
import { AppStateContext } from '../contexts/AppStateContext.jsx'; // Correct named import for the context object

export const useTheme = () => {
    const context = useContext(AppStateContext); // Use the imported context object
    if (!context) {
        throw new Error('useTheme must be used within an AppStateProvider');
    }
    return { theme: context.theme, toggleTheme: context.toggleTheme };
};
```

`src/hooks/useWebSpeech.js`

```javascript
import { useState, useEffect, useCallback } from 'react';

const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;

export const useWebSpeech = () => {
    const [transcript, setTranscript] = useState('');
    const [listening, setListening] = useState(false);
    const [recognitionInstance, setRecognitionInstance] = useState(null);
    const isSpeechSupported = !!SpeechRecognition;

    useEffect(() => {
        if (!isSpeechSupported) {
            console.warn("Web Speech API is not supported by this browser.");
            return;
        }

        const recognition = new SpeechRecognition();
        recognition.continuous = false; // Set to true if you want it to keep listening
        recognition.interimResults = false; // Set to true for live results
        recognition.lang = 'en-US';

        recognition.onresult = (event) => {
            const currentTranscript = Array.from(event.results)
                .map(result => result[0])
                .map(result => result.transcript)
                .join('');
            setTranscript(currentTranscript);
            // console.log("Voice input result:", currentTranscript);
        };

        recognition.onerror = (event) => {
            console.error("Speech recognition error:", event.error);
            // Handle common errors like 'no-speech', 'audio-capture', 'not-allowed'
            if (event.error === 'not-allowed') {
                alert("Microphone permission denied. Please allow microphone access in your browser settings.");
            }
            setListening(false);
        };

        recognition.onend = () => {
            setListening(false);
            // console.log("Speech recognition ended.");
        };
        
        setRecognitionInstance(recognition);

        // Cleanup
        return () => {
            if (recognition) {
                recognition.stop();
            }
        };
    }, [isSpeechSupported]);

    const startListening = useCallback(() => {
        if (recognitionInstance && !listening) {
            try {
                setTranscript(''); // Clear previous transcript
                recognitionInstance.start();
                setListening(true);
                // console.log("Speech recognition started.");
            } catch (e) {
                console.error("Error starting speech recognition:", e);
                setListening(false); // Ensure listening state is correct
            }
        }
    }, [recognitionInstance, listening]);

    const stopListening = useCallback(() => {
        if (recognitionInstance && listening) {
            recognitionInstance.stop();
            setListening(false); // Manually set as onend might be delayed
            // console.log("Speech recognition stopped manually.");
        }
    }, [recognitionInstance, listening]);

    const resetTranscript = useCallback(() => {
        setTranscript('');
    }, []);


    return {
        transcript,
        listening,
        isSpeechSupported,
        startListening,
        stopListening,
        resetTranscript
    };
};
```

`src/index.css`

```css
@tailwind base;
@tailwind components;
@tailwind utilities;

/* You can add global styles or custom component styles here if needed */
body {
  @apply bg-background-light text-text-light dark:bg-background-dark dark:text-text-dark transition-colors duration-300;
  font-family: 'Inter', sans-serif; /* Match theme */
}

/* Example custom component styling that can be applied with Tailwind */
.btn-primary-custom {
  @apply bg-primary text-white font-semibold py-2 px-4 rounded-lg shadow-md hover:bg-primary-dark focus:outline-none focus:ring-2 focus:ring-primary focus:ring-opacity-75 transition-all duration-150;
}

.card-custom {
  @apply bg-surface-light dark:bg-surface-dark shadow-lg rounded-xl overflow-hidden;
}

.card-header-custom {
  @apply bg-gray-100 dark:bg-gray-700 px-6 py-4 border-b border-gray-200 dark:border-gray-600;
}

.input-custom {
    @apply block w-full px-4 py-2 text-text-light dark:text-text-dark bg-surface-light dark:bg-surface-dark border border-secondary-light dark:border-secondary-dark rounded-md shadow-sm focus:outline-none focus:ring-primary focus:border-primary sm:text-sm;
}

/* For scrollbars if desired globally */
::-webkit-scrollbar {
    width: 8px;
    height: 8px;
}
::-webkit-scrollbar-track {
    @apply bg-gray-200 dark:bg-gray-700 rounded-full;
}
::-webkit-scrollbar-thumb {
    @apply bg-secondary dark:bg-secondary-dark rounded-full border-2 border-transparent bg-clip-content;
}
::-webkit-scrollbar-thumb:hover {
    @apply bg-opacity-75;
}
```

`src/main.jsx`

```javascript
// import { StrictMode } from 'react'
// import { createRoot } from 'react-dom/client'
// import './index.css'
// import App from './App.jsx'

// createRoot(document.getElementById('root')).render(
//   <StrictMode>
//     <App />
//   </StrictMode>,
// )
import React from 'react'
import ReactDOM from 'react-dom/client'
import { useAppState } from './contexts/AppStateContext.jsx'; // Correct named import
import App from './App.jsx'
import { AuthProvider } from './contexts/AuthContext.jsx'
import { AppStateProvider } from './contexts/AppStateContext.jsx'
import { Toaster } from 'react-hot-toast'; // For notifications
import './index.css' // Tailwind and global styles

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <AuthProvider>
      <AppStateProvider>
        <App />
        <Toaster position="top-right" reverseOrder={false} />
      </AppStateProvider>
    </AuthProvider>
  </React.StrictMode>,
)
```

`src/services/api.js`

```javascript
// import axios from 'axios';

// // Configure Axios instance
// const apiClient = axios.create({
//     baseURL: import.meta.env.VITE_API_BASE_URL || process.env.REACT_APP_API_BASE_URL || 'http://localhost:5001/api',
//     headers: {
//         'Content-Type': 'application/json',
//     }
// });

// // Add a request interceptor to include the token
// apiClient.interceptors.request.use(config => {
//     const token = localStorage.getItem('authToken');
//     if (token) {
//         config.headers.Authorization = `Bearer ${token}`;
//     }
//     return config;
// }, error => {
//     return Promise.reject(error);
// });


// const api = {
//     // --- Auth ---
//     login: async (credentials) => { // {username, password}
//         const response = await apiClient.post('/auth/signin', credentials);
//         return response.data; // Expects { token, username, _id, sessionId }
//     },
//     signup: async (userData) => { // {username, password, llmProvider (optional), apiKey (optional, if handled by backend securely) }
//         // The backend should ideally handle API key storage securely and not just echo it.
//         // llmProvider and apiKey might be part of user preferences updated later.
//         const response = await apiClient.post('/auth/signup', userData);
//         return response.data; // Expects { token, username, _id, sessionId }
//     },
//     // Maybe a /auth/me endpoint to verify token and get user details
//     // verifyToken: async () => {
//     //     const response = await apiClient.get('/auth/me');
//     //     return response.data;
//     // },


//     // --- Chat ---
//     sendMessage: async (payload) => { // { query, history, sessionId, useRag (boolean) }
//         const response = await apiClient.post('/chat/message', payload);
//         return response.data; // Expects { reply: {role, parts, thinking, references, timestamp}, sessionId, source_pipeline }
//     },
//     getChatHistory: async (sessionId) => {
//         const response = await apiClient.get(`/chat/history/${sessionId}`);
//         return response.data; // Expects array of messages
//     },
//     getChatSessions: async () => {
//         const response = await apiClient.get('/chat/sessions');
//         return response.data; // Expects array of { sessionId, updatedAt, messageCount, preview }
//     },
//     startNewSession: async () => {
//         const response = await apiClient.post('/chat/new_session', {});
//         return response.data; // Expects { sessionId }
//     },

//     // --- Files ---
//     uploadFile: async (formData, onUploadProgress) => {
//         const response = await apiClient.post('/upload', formData, {
//             headers: { 'Content-Type': 'multipart/form-data' },
//             onUploadProgress: onUploadProgress
//         });
//         return response.data; // Expects { message, filename, originalname }
//     },
//     getFiles: async () => {
//         const response = await apiClient.get('/files');
//         return response.data; // Expects array of file objects
//     },
//     renameFile: async (serverFilename, newOriginalName) => {
//         const response = await apiClient.patch(`/files/${serverFilename}`, { newOriginalName });
//         return response.data;
//     },
//     deleteFile: async (serverFilename) => {
//         const response = await apiClient.delete(`/files/${serverFilename}`);
//         return response.data;
//     },

//     // --- Analysis ---
//     requestAnalysis: async (payload) => { // { filename, analysis_type, (optional) file_path if needed by backend}
//         const response = await apiClient.post('/analysis/document', payload);
//         return response.data; // Expects { content, thinking }
//     },

//     // --- Syllabus (if still used) ---
//     getSyllabus: async (subjectId) => {
//         const response = await apiClient.get(`/syllabus/${subjectId}`);
//         return response.data;
//     },
    
//     // --- User Preferences / LLM Config ---
//     // These are NEW endpoints your backend friend would need to implement
//     updateUserLLMConfig: async (configData) => { // { llmProvider, apiKey (if applicable for Gemini) }
//         // Backend should encrypt and store API keys securely.
//         // This endpoint would update the user's preference for LLM and their Gemini key.
//         // The Ollama URL is usually configured server-side for the Local RAG service.
//         const response = await apiClient.post('/user/config/llm', configData);
//         return response.data;
//     },
//     getUserLLMConfig: async () => {
//         // Returns user's current LLM preference, perhaps not the actual key.
//         const response = await apiClient.get('/user/config/llm');
//         return response.data; // Expects { llmProvider: 'ollama' | 'gemini' }
//     },


//     // --- Status ---
//     getOrchestratorStatus: async () => {
//         try {
//             // Base URL for apiClient is already /api, so go up one level for general health
//             const healthUrl = (import.meta.env.VITE_API_BASE_URL || process.env.REACT_APP_API_BASE_URL || 'http://localhost:5001/api').replace('/api', '');
//             const response = await axios.get(`${healthUrl}/api/health`);
//             return response.data;
//         } catch (error) {
//             console.warn("Failed to fetch orchestrator status:", error);
//             return { status: "error", message: "Orchestrator unreachable" };
//         }
//     },
// };

// export default api;
// // Also export the apiClient instance if you need to use it directly sometimes
// export { apiClient };















// import axios from 'axios';

// const DEV_MODE_MOCK_API = true; // Set this to true or false as needed

// // --- Define apiClient at the top level ---
// const apiClient = axios.create({
//     baseURL: import.meta.env.VITE_API_BASE_URL || process.env.REACT_APP_API_BASE_URL || 'http://localhost:5001/api',
//     headers: {
//         'Content-Type': 'application/json',
//     }
// });

// // Add a request interceptor to include the token (if not in dev mode or if real calls are made in dev mode)
// if (!DEV_MODE_MOCK_API) { // Or adjust this logic if some dev calls are real
//     apiClient.interceptors.request.use(config => {
//         const token = localStorage.getItem('authToken');
//         if (token) {
//             config.headers.Authorization = `Bearer ${token}`;
//         }
//         return config;
//     }, error => {
//         return Promise.reject(error);
//     });
// }
// // If you want the interceptor to always run, even for potential real calls during dev mode, move it outside the if.
// // For purely mocked API, the interceptor might not be strictly necessary.
// // However, it's good practice to have it for when DEV_MODE_MOCK_API is false.
// // Let's make it always active for consistency when switching modes:
// apiClient.interceptors.request.use(config => {
//     if (DEV_MODE_MOCK_API && config.url.startsWith(apiClient.defaults.baseURL)) {
//         // If mocking and it's a call to our base URL, we might not need the token.
//         // However, if some mock functions call the real apiClient, token might be needed.
//         // For simplicity with full mocking, let's assume token isn't added for mock calls.
//         // BUT, if you have a mix, you'd need more nuanced logic.
//         // Given our setup, the mock functions DON'T use apiClient directly.
//         // So this interceptor will only apply when DEV_MODE_MOCK_API is false.
//     }
//     const token = localStorage.getItem('authToken');
//     if (token) {
//         config.headers.Authorization = `Bearer ${token}`;
//     }
//     return config;
// }, error => {
//     return Promise.reject(error);
// });


// const mockDelay = (ms = 500) => new Promise(resolve => setTimeout(resolve, ms));

// const api = {
//     login: async (credentials) => {
//         if (DEV_MODE_MOCK_API) {
//             await mockDelay();
//             console.log("MOCK API: login", credentials);
//             if (credentials.username === "test" && credentials.password === "password") { // Example mock credentials
//                 return { token: 'mock-token-xyz', username: 'TestUser', _id: 'testuser123', sessionId: 'mock-session-123' };
//             } else if (credentials.username === "DevUser" && credentials.password === "devpass") { // For the AuthContext bypass
//                  return { token: 'fake-dev-token', username: 'DevUser', _id: 'devUser123', sessionId: 'dev-session-123' };
//             }
//             // Simulate a failure for other credentials if needed for testing UI
//             throw new Error("Invalid mock credentials");
//         }
//         // Real API call
//         const response = await apiClient.post('/auth/signin', credentials);
//         return response.data;
//     },
//     signup: async (userData) => {
//         if (DEV_MODE_MOCK_API) {
//             await mockDelay();
//             console.log("MOCK API: signup", userData);
//             return { token: 'mock-signup-token-xyz', username: userData.username, _id: `newmock-${Date.now()}`, sessionId: `mock-session-signup-${Date.now()}` };
//         }
//         // Real API call
//         const response = await apiClient.post('/auth/signup', userData);
//         return response.data;
//     },
    
//     sendMessage: async (payload) => {
//         if (DEV_MODE_MOCK_API) {
//             await mockDelay(payload.useRag ? 2000 : 1000); // Slower for RAG
//             console.log("MOCK API: sendMessage", payload);
//             const botText = payload.useRag 
//                 ? `This is a MOCKED RAG response to: "${payload.query}". \n\nIt uses your documents (not really). Source [1] is very relevant. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nullam in dui mauris.`
//                 : `This is a MOCKED direct LLM response to: "${payload.query}". \n\nSed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium.`;
//             const thinkingText = payload.useRag 
//                 ? "<thinking>\n1. User query analyzed: seeking information via RAG.\n2. (Mock) Searched user documents for keywords: '" + payload.query.split(" ")[0] + "'.\n3. (Mock) Found 1 relevant chunk in 'mock_document.pdf'.\n4. (Mock) Synthesizing answer based on this chunk and general knowledge.\n</thinking>" 
//                 : null;
//             const references = payload.useRag 
//                 ? [{ number: 1, source: "mock_document.pdf", content_preview: "This is a preview of the mock document containing key information related to the query..."}] 
//                 : [];
            
//             return { 
//                 reply: {
//                     role: 'model', 
//                     parts: [{text: botText }], 
//                     thinking: thinkingText, 
//                     references: references,
//                     timestamp: new Date().toISOString()
//                 }, 
//                 sessionId: payload.sessionId, 
//                 source_pipeline: payload.useRag ? 'mock_ollama_rag' : 'mock_gemini_direct'
//             };
//         }
//         // Real API call
//         const response = await apiClient.post('/chat/message', payload);
//         return response.data;
//     },
//     getChatHistory: async (sessionId) => {
//         if (DEV_MODE_MOCK_API) {
//             await mockDelay(300);
//             console.log("MOCK API: getChatHistory for session", sessionId);
//             if (sessionId === 'dev-session-123' || sessionId === 'mock-session-123' || sessionId === 'dev-session-appjsx-123') {
//                  return [
//                     { _id: 'hist1', role: 'user', parts: [{text: "Hello AI! How does mocking work?"}], timestamp: new Date(Date.now() - 120000).toISOString() },
//                     { _id: 'hist2', role: 'model', parts: [{text: "Hello User! Mocking involves simulating backend responses so you can test the frontend independently. This is a mocked history message."}], thinking: null, references: [], timestamp: new Date(Date.now() - 100000).toISOString(), source_pipeline: 'mock_gemini_direct' },
//                     { _id: 'hist3', role: 'user', parts: [{text: "Tell me about RAG."}], timestamp: new Date(Date.now() - 60000).toISOString() },
//                     { _id: 'hist4', role: 'model', parts: [{text: "RAG stands for Retrieval Augmented Generation. It enhances LLM responses by first retrieving relevant information from a knowledge base. This is a mocked explanation from RAG."}], thinking: "<thinking>User asked about RAG. This is a core concept. I will explain it briefly.</thinking>", references: [{number: 1, source: "RAG_explanation_doc.pdf", content_preview:"RAG combines retrieval with generation..."}], timestamp: new Date(Date.now() - 50000).toISOString(), source_pipeline: 'mock_ollama_rag' },
//                 ];
//             }
//             return [];
//         }
//         // Real API call
//         const response = await apiClient.get(`/chat/history/${sessionId}`);
//         return response.data;
//     },
//     getChatSessions: async () => {
//         if (DEV_MODE_MOCK_API) {
//             await mockDelay(400);
//             console.log("MOCK API: getChatSessions");
//             return [
//                 { sessionId: 'mock-session-123', updatedAt: new Date().toISOString(), messageCount: 4, preview: "RAG stands for Retrieval Augmented..." },
//                 { sessionId: 'another-mock-session', updatedAt: new Date(Date.now() - 7200000).toISOString(), messageCount: 10, preview: "Discussing advanced mock topics in detail..." }
//             ];
//         }
//         // Real API call
//         const response = await apiClient.get('/chat/sessions');
//         return response.data;
//     },
//     startNewSession: async () => {
//         if (DEV_MODE_MOCK_API) {
//             await mockDelay(100);
//             const newMockSessionId = `mock-session-${Date.now()}`;
//             console.log("MOCK API: startNewSession, created:", newMockSessionId);
//             return { sessionId: newMockSessionId };
//         }
//         // Real API call
//         const response = await apiClient.post('/chat/new_session', {});
//         return response.data;
//     },

//     // Mock File Operations
//     uploadFile: async (formData, onUploadProgress) => {
//         if (DEV_MODE_MOCK_API) {
//             const mockFileName = formData.get('file')?.name || 'mock_uploaded_file.pdf';
//             console.log("MOCK API: uploadFile", mockFileName);
//             if (onUploadProgress) { /* ... simulate progress ... */ }
//             await mockDelay(1200);
//             return { message: `${mockFileName} uploaded (mocked)!`, filename: `server-${mockFileName}`, originalname: mockFileName };
//         }
//         // Real API call
//         const response = await apiClient.post('/upload', formData, {
//             headers: { 'Content-Type': 'multipart/form-data' },
//             onUploadProgress: onUploadProgress
//         });
//         return response.data;
//     },
//     getFiles: async () => {
//         if (DEV_MODE_MOCK_API) {
//             await mockDelay(200);
//             console.log("MOCK API: getFiles");
//             return [
//                 { serverFilename: 'mock-server-doc1.pdf', originalName: 'My Research Paper.pdf', type: 'application/pdf', size: 123456, lastModified: new Date().toISOString() },
//                 { serverFilename: 'mock-server-code1.py', originalName: 'script.py', type: 'text/x-python', size: 7890, lastModified: new Date().toISOString() },
//                 { serverFilename: 'mock-manual.txt', originalName: 'User Manual.txt', type: 'text/plain', size: 30250, lastModified: new Date(Date.now()- 86400000).toISOString() },

//             ];
//         }
//         // Real API call
//         const response = await apiClient.get('/files');
//         return response.data;
//     },
//     renameFile: async (serverFilename, newOriginalName) => {
//          if (DEV_MODE_MOCK_API) {
//             await mockDelay(300);
//             console.log("MOCK API: renameFile", serverFilename, "to", newOriginalName);
//             // Find and update in mock data if you want the list to reflect it immediately
//             return { message: "File renamed (mocked)" };
//         }
//         // Real API call
//         const response = await apiClient.patch(`/files/${serverFilename}`, { newOriginalName });
//         return response.data;
//     },
//     deleteFile: async (serverFilename) => {
//          if (DEV_MODE_MOCK_API) {
//             await mockDelay(300);
//             console.log("MOCK API: deleteFile", serverFilename);
//             // Remove from mock data if needed for UI consistency
//             return { message: "File deleted (mocked)" };
//         }
//         // Real API call
//         const response = await apiClient.delete(`/files/${serverFilename}`);
//         return response.data;
//     },

//     // Mock Analysis
//     requestAnalysis: async (payload) => {
//         if (DEV_MODE_MOCK_API) {
//             await mockDelay(payload.analysis_type === 'mindmap' ? 3000 : 1500);
//             console.log("MOCK API: requestAnalysis", payload);
//             let content = `## Mocked ${payload.analysis_type.toUpperCase()} for: *${payload.filename}*\n\n`;
//             if (payload.analysis_type === 'faq') {
//                 content += "**Q1: What is this document about (mocked)?**\nA1: This document (mockingly) covers key concepts related to your query.\n\n**Q2: How is this FAQ generated (mocked)?**\nA2: It's simulated for UI testing purposes, based on the selected document name and analysis type.";
//             } else if (payload.analysis_type === 'topics') {
//                 content += "- **Mock Topic 1:** Core ideas from the document (simulated).\n- **Mock Topic 2:** Frontend and UI development strategies.\n- **Mock Topic 3:** Backend API simulation techniques.";
//             } else if (payload.analysis_type === 'mindmap') {
//                 content = `# Mocked Mindmap: ${payload.filename}\n## Main Idea 1\n### Sub-Idea 1.1\n### Sub-Idea 1.2\n#### Detail 1.2.1\n## Main Idea 2\n### Sub-Idea 2.1`;
//             }
//             return { content: content, thinking: "Mocked thinking process:\n1. Received analysis request for '" + payload.filename + "' (type: "+payload.analysis_type+").\n2. (Mock) Loaded document content.\n3. (Mock) Applied specific LLM prompt for "+payload.analysis_type+".\n4. Generated the mock output displayed." };
//         }
//         // Real API call
//         const response = await apiClient.post('/analysis/document', payload);
//         return response.data;
//     },
    
//     updateUserLLMConfig: async (configData) => {
//         if (DEV_MODE_MOCK_API) {
//             await mockDelay(); console.log("MOCK API: updateUserLLMConfig", configData);
//             localStorage.setItem('mockSelectedLLM', configData.llmProvider);
//             if(configData.llmProvider === 'gemini' && configData.apiKey){ localStorage.setItem('mockGeminiApiKeyStatus', 'KeyProvided(Mock)'); }
//             return { message: `LLM preference updated to ${configData.llmProvider} (mocked).` };
//         }
//         const response = await apiClient.post('/user/config/llm', configData);
//         return response.data;
//     },
//     getUserLLMConfig: async () => {
//          if (DEV_MODE_MOCK_API) {
//             await mockDelay();
//             const mockLLM = localStorage.getItem('mockSelectedLLM') || 'ollama';
//             console.log("MOCK API: getUserLLMConfig, returning:", mockLLM);
//             return { llmProvider: mockLLM };
//         }
//         const response = await apiClient.get('/user/config/llm');
//         return response.data;
//     },

//     getOrchestratorStatus: async () => {
//         if (DEV_MODE_MOCK_API) {
//             await mockDelay(100);
//             return { status: "ok", message: "Orchestrator (Mocked & Online)", database_status: "Connected" };
//         }
//         try {
//             const healthUrl = (import.meta.env.VITE_API_BASE_URL || process.env.REACT_APP_API_BASE_URL || 'http://localhost:5001/api').replace('/api', '');
//             const response = await axios.get(`${healthUrl}/api/health`); // Use axios directly for non-apiClient base URL
//             return response.data;
//         } catch (error) {
//             console.warn("Failed to fetch orchestrator status:", error);
//             return { status: "error", message: "Orchestrator unreachable" };
//         }
//     },
//     // Add syllabus if needed
//     getSyllabus: async (subjectId) => {
//         if(DEV_MODE_MOCK_API) {
//             await mockDelay();
//             console.log("MOCK API: getSyllabus", subjectId);
//             return `# Mock Syllabus for ${subjectId}\n\n- Topic 1\n- Topic 2`;
//         }
//         const response = await apiClient.get(`/syllabus/${subjectId}`);
//         return response.data;
//     }
// };

// export default api;
// export { apiClient }; // Export apiClient itself if needed for direct use (e.g. file uploads with custom config)








import axios from 'axios';

const DEV_MODE_MOCK_API = false; // <--- SET TO FALSE to make real API calls

const apiClient = axios.create({
    baseURL: import.meta.env.VITE_API_BASE_URL || 'http://localhost:5001/api',
    headers: { 'Content-Type': 'application/json' }
});

apiClient.interceptors.request.use(config => {
    const token = localStorage.getItem('authToken');
    if (token) { // Always try to add token if it exists for real calls
        config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
}, error => Promise.reject(error));

// Mock functions are only used if DEV_MODE_MOCK_API is true
const mockDelay = (ms = 300) => new Promise(resolve => setTimeout(resolve, ms));
const MOCKED_FILES_STORE_API = [ /* ... your mock files ... */ ];
let MOCKED_CHAT_HISTORY_API = {};

const api = {
    login: async (credentials) => {
        if (DEV_MODE_MOCK_API) { 
            await mockDelay(); console.log("MOCK API: login", credentials);
            const username = credentials.username || 'DevUser';
            if ((username === 'DevUser' && credentials.password === 'devpass') || (username === 'test' && credentials.password === 'password')) {
                 return { token: `mock-token-${username}`, username, _id: `mock-id-${username}`, sessionId: `mock-session-${Date.now()}` };
            }
            throw new Error("Mock: Invalid credentials");
        }
        const response = await apiClient.post('/auth/signin', credentials);
        return response.data;
    },
    signup: async (userData) => {
        if (DEV_MODE_MOCK_API) { /* ... as in previous full mock ... */ }
        const response = await apiClient.post('/auth/signup', userData);
        return response.data;
    },
    sendMessage: async (payload) => {
        if (DEV_MODE_MOCK_API) { /* ... as in previous full mock ... */ }
        const response = await apiClient.post('/chat/message', payload);
        return response.data;
    },
    getChatHistory: async (sessionId) => {
        if (DEV_MODE_MOCK_API) { /* ... as in previous full mock ... */ }
        const response = await apiClient.get(`/chat/history/${sessionId}`);
        return response.data;
    },
    getChatSessions: async () => {
        if (DEV_MODE_MOCK_API) { /* ... as in previous full mock ... */ }
        const response = await apiClient.get('/chat/sessions');
        return response.data;
    },
    startNewSession: async () => {
        if (DEV_MODE_MOCK_API) { /* ... as in previous full mock ... */ }
        const response = await apiClient.post('/chat/new_session', {});
        return response.data;
    },
    uploadFile: async (formData, onUploadProgress) => {
        if (DEV_MODE_MOCK_API) { /* ... as in previous full mock ... */ }
        const response = await apiClient.post('/upload', formData, {
            headers: { 'Content-Type': 'multipart/form-data' }, // Token added by interceptor
            onUploadProgress
        });
        return response.data;
    },
    getFiles: async () => {
        if (DEV_MODE_MOCK_API) { /* ... as in previous full mock ... */ }
        const response = await apiClient.get('/files');
        return response.data;
    },
    renameFile: async (serverFilename, newOriginalName) => {
        if (DEV_MODE_MOCK_API) { /* ... as in previous full mock ... */ }
        const response = await apiClient.patch(`/files/${serverFilename}`, { newOriginalName });
        return response.data;
    },
    deleteFile: async (serverFilename) => {
        if (DEV_MODE_MOCK_API) { /* ... as in previous full mock ... */ }
        const response = await apiClient.delete(`/files/${serverFilename}`);
        return response.data;
    },
    requestAnalysis: async (payload) => {
        if (DEV_MODE_MOCK_API) { /* ... as in previous full mock ... */ }
        const response = await apiClient.post('/analysis/document', payload);
        return response.data;
    },
    updateUserLLMConfig: async (configData) => {
        if (DEV_MODE_MOCK_API) { /* ... as in previous full mock ... */ }
        const response = await apiClient.post('/user/config/llm', configData);
        return response.data;
    },
    getUserLLMConfig: async () => {
        if (DEV_MODE_MOCK_API) { /* ... as in previous full mock ... */ }
        const response = await apiClient.get('/user/config/llm');
        return response.data;
    },
    getOrchestratorStatus: async () => {
        if (DEV_MODE_MOCK_API) { return { status: "ok", message: "Backend (Mocked & Healthy)", database_status: "Connected" };}
        const baseUrlForHealth = (import.meta.env.VITE_API_BASE_URL || 'http://localhost:5001/api').replace('/api', '');
        const response = await axios.get(`${baseUrlForHealth}/api/health`);
        return response.data;
    },
    getSyllabus: async (subjectId) => {
        if(DEV_MODE_MOCK_API) { /* ... as in previous full mock ... */ }
        const response = await apiClient.get(`/syllabus/${subjectId}`);
        return response.data;
    }
};

export default api;
export { apiClient };
```

`src/utils/helpers.js`

```javascript
// Debounce function: Limits the rate at which a function can fire.
export const debounce = (func, delay) => {
    let timeoutId;
    return function(...args) {
        const context = this;
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => func.apply(context, args), delay);
    };
};

// Throttle function: Ensures a function is called at most once in a specified time period.
export const throttle = (func, limit) => {
    let inThrottle;
    let lastFunc;
    let lastRan;
    return function(...args) {
        const context = this;
        if (!inThrottle) {
            func.apply(context, args);
            lastRan = Date.now();
            inThrottle = true;
            setTimeout(() => {
                inThrottle = false;
                if (lastFunc) {
                    lastFunc.apply(context, args); // Call with latest args if throttled
                    lastRan = Date.now();
                }
            }, limit);
        } else {
            lastFunc = func; // Store the latest call
        }
    };
};

// Simple function to format file size
export const formatFileSize = (bytes, decimals = 2) => {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const dm = decimals < 0 ? 0 : decimals;
    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
};

// Function to generate a simple unique ID (for client-side list keys, etc.)
export const generateUniqueId = (prefix = 'id') => {
    return `${prefix}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
};

// Function to safely get nested property
export const getNestedValue = (obj, path, defaultValue = undefined) => {
    const value = path.split('.').reduce((acc, part) => acc && acc[part], obj);
    return value === undefined ? defaultValue : value;
};

// Basic HTML escape (can be more comprehensive)
export const escapeHtml = (unsafe) => {
    if (typeof unsafe !== 'string') return '';
    return unsafe
         .replace(/&/g, "&")
         .replace(/</g, "<")
         .replace(/>/g, ">")
         .replace(/"/g, '"')
         .replace(/'/g, "'");
};

// You can add more utility functions here as your project grows.
// For example, date formatting, string manipulation, etc.

// Example: Truncate text
export const truncateText = (text, maxLength = 100) => {
    if (!text || text.length <= maxLength) return text;
    return text.substring(0, maxLength) + '...';
};
```

`tailwind.config.js`

```javascript
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  darkMode: 'class', // or 'media' if you prefer OS-level theme preference
  theme: {
    extend: {
      colors: {
        // Define your professional blues/grays and accent colors here
        // Example:
        'primary': {
          light: '#A7C7E7', // Light blue
          DEFAULT: '#3B82F6', // Blue
          dark: '#1E40AF',  // Dark blue
        },
        'secondary': {
          light: '#E5E7EB', // Light gray
          DEFAULT: '#6B7280', // Gray
          dark: '#374151',  // Dark gray
        },
        'accent': '#F59E0B', // Amber/Orange accent
        'background': {
          light: '#F9FAFB', // Very light gray for light mode background
          dark: '#111827',  // Very dark gray/blue for dark mode background
        },
        'surface': {
            light: '#FFFFFF', // White for light mode surfaces (cards, etc.)
            dark: '#1F2937',  // Darker gray for dark mode surfaces
        },
        'text': {
            light: '#111827', // Dark text for light mode
            dark: '#E5E7EB',  // Light text for dark mode
        },
        'text-muted': {
            light: '#6B7280',
            dark: '#9CA3AF',
        }
      },
      fontFamily: {
        sans: ['Inter', 'sans-serif'], // Example: Using Inter font
      },
      // Add custom animations, transitions, etc.
      keyframes: {
        fadeIn: {
          '0%': { opacity: '0' },
          '100%': { opacity: '1' },
        },
        slideInLeft: {
          '0%': { transform: 'translateX(-100%)', opacity: '0'},
          '100%': { transform: 'translateX(0)', opacity: '1'},
        }
        // ... more keyframes
      },
      animation: {
        fadeIn: 'fadeIn 0.5s ease-out',
        slideInLeft: 'slideInLeft 0.5s ease-out',
        // ... more animations
      }
    },
  },
  plugins: [],
}



```

`vite.config.js`

```javascript
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
})

```

